---
tags:
  - 题解
aliases:
---
## [F - Dangerous Sugoroku](https://atcoder.jp/contests/abc388/tasks/abc388_f)

### 解法一

由于共有 $N$ 个格子，无法对每个格子都判断能否到达。因此，我们只对部分格子进行判断以加速处理。
取连续好格子段的前 $B$ 个格子和后 $B$ 个格子进行计算，总状态数为 $O(MB)$。
从一段坏格子左侧跨越到右侧，可以通过枚举左侧后 $B$ 个格子，再前进 $A\leq i\leq B$ 格，进行 $O(B^2)$ 的转移。
从一段好格子的左侧跨越到右侧，如果能在 $O(1)$ 时间内解决“在没有坏格子的情况下能否前进 $w$ 个格子”的问题，那么这种情况也可以在 $O(B^2)$ 时间内完成计算。
由于 $A < B$，前进 $B - 1$ 个格子和前进 $B$ 个格子都是可行的。记前进了 $k$ 次，每次可以从第 $k-1$ 次的每一个格子前进 $B-1$ 或 $B$，由数学归纳法可知每次前进所能到达的格子一定是连续的。如果每次都走 $B-1$，前进的格子数为 $k(B-1)$，每次都走 $B$，前进的格子数为 $kB$，因此第 $k$ 次覆盖格子的长度为 $kB-k(B-1)+1=k+1$，当 $k\geq B-1$ 时，能覆盖所有格子。当 $k=B-2$ 时，所能到达的最左侧的格子为 $(B-1)(B-2)=B^2 - 3B + 2$，从这一格向右开始，都一定可以通过若干步到达。
因此当 $w \geq B^2 - 3B + 2$ 时，一定可以前进 $w$ 个格子。当 $w < B^2 - 3B + 2$ 时，可以预先使用简单的 $O(B^3)$ 时间的 dp 进行计算。
综上所述，整体计算可以在 $O(MB^2 + B^3)$ 时间内完成。


#### [AC 代码]()

```cpp

```

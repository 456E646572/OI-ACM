---
tags:
  - 题解
  - DP
aliases:
  - H. Sheet Music
---
## [H. Sheet Music](https://codeforces.com/contest/2041/problem/H)

我们先尝试构造一个仅包含 $\texttt{>}$ 和 $\texttt{<}$ 的、长度为 $i$ 的不等号序列，第 $i$ 位上的符号表示 $a_{i-1}$ 与 $a_i$ 的相对大小关系。这个不等号序列只需要满足一个限制条件：连续的不等号段长度不超过 $k-1$。因为如果有 $k$ 个连续的不等号，$a$ 中就需要至少 $k+1$ 个不同数字，这与值域 $[1,k]$ 的限制相违背。而当出现连续 $k-1$ 个不等号，即音符序列为 $1,2,\cdots,k$ 时，可以令下一个音符变成 $1$ 或 $k-1$，就可以再往后添加连续 $k-1$ 个不等号。
记 $dp[z][i]$ 表示第 $i$ 与第 $i-1$ 位关系为 $z$ 的方案数，其中，$z=0$ 表示 $a_{i-1}<a_i$，$z=1$ 表示 $a_{i-1}>a_i$。记 $sum[z][i]=\sum_{k=1}^idp[z][k]$。
考虑第 $i$ 位填 $\texttt{>}$ 的情况，前 $i-1$ 个位置上可以以 $\texttt{<}$ 结尾，可以以 $\texttt{<},\texttt{>}$ 结尾，可以以 $\texttt{<},\texttt{>},\texttt{>}$ 结尾……，可以以 $\texttt{<},\underbrace{\texttt{>},\texttt{>},\cdots,\texttt{>},\texttt{>}}_{k-2 \text{个} \texttt{>}}$ 结尾。对应的方案数分别为 $dp[0][i-1],dp[0][i-2],\cdots,dp[0][i-k]$。于是状态转移方程为：
$$
dp[z][i] = \begin{cases}
sum[z\textasciicircum 1][i-1]-sum[z\textasciicircum 1][i-k-1] & i-k-1\geq0 \\
sum[z\textasciicircum 1][i-1] & i-k-1<0
\end{cases}
$$
完成 $dp$ 的更新后对应维护 $sum$ 即可。最终答案为 $\displaystyle\sum_{0\leq k\leq n}C_n^k\cdot (dp[k][0]+dp[k][1])$。

#### [AC 代码]()

```cpp
#include <bits/stdc++.h>
using namespace std;
template <typename T1, typename T2>
ostream& operator<<(ostream& out, pair<T1, T2> p) {
    out << "(" << p.first << "," << p.second << ")";
    return out;
}
template <typename T>
ostream& operator<<(ostream& out, vector<T> v) {
    out << "[";
    if (!v.empty()) {
        cout << v[0];
        for (int i = 1; i < v.size(); i++) cout << "," << v[i];
    }
    out << "]";
    return out;
}
#define int long long
const int maxn = 1e6 + 10;
const int mod = 998244353;
int ksm(int x, int k) {
    int res = 1;
    while (k) {
        if (k & 1) res = res * x % mod;
        x = x * x % mod;
        k /= 2;
    }
    return res;
}
int ny(int x) { return ksm(x, mod - 2); }
void add(int& x, int y) {
    if ((x += y) >= mod) x -= mod;
}
void del(int& x, int y) {
    if ((x -= y) < 0) x += mod;
}
int inv[maxn], fac[maxn];
int C(int n, int m) {
    return n == 0 ? 1 : fac[n] * inv[n - m] % mod * inv[m] % mod;
}
int A(int n, int m) { return n == 0 ? 1 : fac[n] * inv[n - m] % mod; }
void init() {
    inv[0] = fac[0] = 1;
    inv[1] = 1;
    for (int i = 1; i < maxn; i++) {
        fac[i] = fac[i - 1] * i % mod;
    }
    inv[1] = 1;
    for (int i = 2; i < maxn; i++) {
        inv[i] = (int)(mod - mod / i) * inv[mod % i] % mod;
    }
    inv[0] = 1;
    for (int i = 1; i < maxn; i++) {
        inv[i] = inv[i - 1] * inv[i] % mod;
    }
}
signed main() {
    init();
    int n, k;
    cin >> n >> k;
    if (n == 1) {
        cout << 1;
        return 0;
    }
    n--;
    k--;
    vector<vector<int>> dp(2, vector<int>(n + 1));
    vector<vector<int>> sum(2, vector<int>(n + 1));
    int ans = 1;
    dp[0][0] = dp[1][0] = 1;
    sum[0][0] = sum[1][0] = 1;
    for (int i = 1; i <= n; i++) {
        int l = max(0ll, i - k);
        for (int z = 0; z < 2; z++) {
            add(dp[z][i], sum[z ^ 1][i - 1]);
            if (l > 0) del(dp[z][i], sum[z ^ 1][l - 1]);
            sum[z][i] = dp[z][i];
            add(sum[z][i], sum[z][i - 1]);
        }
    }
    // cout << "dp0=" << dp[0] << endl;
    // cout << "dp1=" << dp[1] << endl;
    for (int i = 0; i < n; i++)
        add(ans, C(n, i) * (dp[0][n - i] + dp[1][n - i]) % mod);
    cout << ans << "\n";
}
```

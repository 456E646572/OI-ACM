---
tags:
  - 题解
  - 线段树
  - 扫描线
aliases:
  - P5490 【模板】扫描线 & 矩形面积并
speed:
---
## [P5490 【模板】扫描线 & 矩形面积并](https://www.luogu.com.cn/problem/P5490)

用扫描线（相当于一根移动的数轴）从下到上扫描整个图形，将图形重新分为若干个矩形，面积为底乘高，底边是当前高度上，扫描线被覆盖的长度。扫描线每遇到一条矩形横向边，就重新计算一次当前的底，再乘上两条横向边高度差计算面积。这样，就将面积并转换为了矩形横向边的并。
设 $eg=\{xl,xr,y,mark\}$ 表示每一条矩形的横向边（注意和假想的无限长的扫描线区分），其中 $mark$ 等于 $1$ 或 $-1$，表示这条边是下底边或上底边。每次遇到一条线段，在扫描线上将区间 $[xl,xr]$ 及其子区间加上 $mark$。这样一来，每次遇到下底边，区间 $[xl,xr]$ 及其子区间就会加上 $1$，表示多被覆盖了一次。而一旦遇到下底边，这次的增加就会被清除，并且保证了权值非负。这样一来，扫描线上所有有数字的地方都是新图形底的一部分。
可以再设某段区间 $[l,r]$ 内，属于新图形底的长度为 $len[l,r]$。如果扫描线上 $sum[l,r]>0$，说明区间 $[l,r]$ 被完全覆盖，$len[l,r]=r-l+1$。否则，将 $[l,r]$ 分到左右两个子区间内做，然后合并。区间修改+区间查询+区间合并，可以用线段树维护。
注意这题 $x$ 的范围到 $10^9$，线段树开不下，离散化。此时只需要将线段树维护的区间改为 $[x[l],x[r+1]]$ 即可。


#### [AC代码]()

```cpp

```

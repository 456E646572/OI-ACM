---
tags:
  - 题解
aliases:
  - 【模板】二分图最大匹配
speed:
---
## [P3386 【模板】二分图最大匹配](https://www.luogu.com.cn/problem/P3386)

匈牙利算法利用了以下特点：

- 代码实现时二分图强制左连右
- 以两个非匹配点为端点
- 增广路上匹配边与非匹配边交替
- 增广路取反后不会将匹配点变为非匹配点。

记 $match[v]=u$ 表示左侧点 $u$ 和右侧点 $v$ 匹配。每次强制认为左点 $u$ 为非匹配，将其作为增广路起点，尝试匹配：

- 如果匹配成功，则找到了一条新的增广路，答案加一。注意此步可能找到一条长度为 $1$ 的增广路，直接将其作为匹配边即可。
- 如果 $u$ 与 $v$ 失配，则存在一条从 $v$ 到 $match[v]$ 的匹配边，下一个非匹配边的起点应该为 $match[v]$，递归计算即可。最后记得将增广路上匹配边与非匹配边取反，即修改每个右点的 $match$ 为新的左点。

每次匹配时都用 $vis$ 标记尝试过的点，由于每次尝试都可能更新增广路，因此需要将 $vis$ 清空。

#### [AC代码](https://www.luogu.com.cn/record/176420228)

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N=505, M=505, E=505;
int n, m, e, match[N], ans;
bool vis[N];
vector <int> G[N];

bool dfs(int u)
{
    for (int v: G[u]) {
        if (!vis[v]) {
            vis[v] = true;
            if (!match[v] || dfs(match[v])) {
                match[v] = u; return true;
            }
        }
    }
    return false;
}

int main()
{
    cin >> n >> m >> e;
    for (int i = 1; i <= e; ++i) {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
    }
    for (int i = 1; i <= n; ++i) {
        memset(vis, 0, sizeof(vis));
        ans += dfs(i);
    }
    cout << ans << endl;
}
```

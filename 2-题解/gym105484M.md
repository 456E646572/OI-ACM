---
tags:
  - 题解
aliases:
  - M. Ordainer of Inexorable Judgment
---
## [M. Ordainer of Inexorable Judgment](https://codeforces.com/gym/105484/problem/M)



#### [AC 代码](https://codeforces.com/gym/105484/submission/299443128)

```cpp
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
typedef long double db;
const db PI=acos(-1.0);

struct Point {
	db x, y;
    Point(db x=0, db y=0): x(x), y(y) { }
    db ang() { return atan2(y, x); }
	db operator ^ (const Point &p) const { // 叉乘，用的时候记得打括号
	    return x*p.y - y*p.x;
	}
};

// 在一个半平面内做极角排序，即 toLeft 测试
bool cmp(Point a, Point b)
{
    return (a ^ b) > 0;
}

db normalizeAngle(db x)
{
    x = fmod(x, 2*PI);
    if (x < 0) { x += 2*PI; }
    return x;
}

db solve(db dur, const vector<pair<db,db>> &s)
{
    db res = 0;
    db dt = fmod(dur, 2*PI);
    for (auto& [l, r]: s) { res += r-l; }
    res *= (dur-dt) / (2*PI);
    for (auto& [l, r]: s) {
        res += max<db>(0, min(dt,r)-l);
    }
    return res;
}

int main()
{
    int n, dx, dy, r, t;
    cin >> n >> dx >> dy >> r >> t;
    vector <Point> Lg, Rg;
    for (int i = 1; i <= n; ++i) {
        db x, y;
        cin >> x >> y;
        db ang=atan2(y, x), dt=asin(r/hypotl(x,y));
        db tl = ang - dt;
        db tr = ang + dt;
        Lg.push_back( Point(cos(tl), sin(tl)));
        Rg.push_back( Point(cos(tr), sin(tr)));
    }
    db tl = normalizeAngle( min_element(Lg.begin(), Lg.end(), cmp) -> ang() );
    db tr = normalizeAngle( max_element(Rg.begin(), Rg.end(), cmp) -> ang() );
    vector <pair<db,db>> s;
    if (tl < tr) {
        s.push_back( { tl, tr } );
    } else {
        s.push_back( { 0, tr } );
        s.push_back( { tl, 2*PI } );
    }
    db d = normalizeAngle(atan2(dy, dx));
    cout << fixed << setprecision(12) << solve(d+t, s)-solve(d, s) << "\n";
}
```

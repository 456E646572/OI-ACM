---
tags:
  - 题解
aliases:
---
## []()



#### [AC 代码]()

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long double db;
const db PI=acos(db(-1));
db solve(db q,const vector<pair<db,db>>& s)
{
    db res=0,qr=fmod(q,2*PI);
    for(auto& [l,r] : s)
        res+=r-l;
    res*=(q-qr)/(2*PI);
    for(auto& [l,r] : s)
        res+=max<db>(0,min(r,qr)-l);
    return res;
}
int main()
{
    int n,dx,dy,r,t;
    scanf("%d%d%d%d%d",&n,&dx,&dy,&r,&t);
    vector<tuple<db,db,db>> lef,rig;
    for(int i=1; i<=n; i++)
    {
        int px,py;
        scanf("%d%d",&px,&py);
        db tp=atan2(py,px);
        db td=asin(r/sqrt(db(px*px+py*py)));
        db tl=tp-td,tr=tp+td;
        lef.emplace_back(cos(tl),sin(tl),tl);
        rig.emplace_back(cos(tr),sin(tr),tr);
    }
    auto cmp=[](const tuple<db,db,db>& lhs,const tuple<db,db,db>& rhs)
    {
        auto& [x1,y1,t1]=lhs;
        auto& [x2,y2,t2]=rhs;
        return x1*y2>x2*y1;
    };
    db tl=get<2>(*min_element(lef.begin(),lef.end(),cmp));
    db tr=get<2>(*max_element(rig.begin(),rig.end(),cmp));
    while(tl<0)tl+=2*PI;
    while(tr<0)tr+=2*PI;
    vector<pair<db,db>> ts;
    if(tl<tr)ts.emplace_back(tl,tr);
    else ts.emplace_back(0,tr),ts.emplace_back(tl,2*PI);
    db q=atan2(dy,dx);
    while(q<0)q+=2*PI;
    return 0*printf("%.12Lf\n",solve(q+t,ts)-solve(q,ts));
}
```

---
tags:
  - 碎片
  - OI
  - OI/反悔贪心
  - OI/堆
  - OI/双向链表
---
## [# P3620 [APIO/CTSC2007] 数据备份](https://www.luogu.com.cn/problem/P3620)

显然，相邻办公楼之间相连，必然优于比非相邻办公楼相连。

类似差分，记录下所有 $d_i=x_i-x_{i-1}$ 的值，然后做法同 [[P1792]]。

需要注意的是，由于要求的是最小值，并且不在办公楼不在环上，所以需要设 $d_1=d_{n+1}=+\infty$，保证不会选择使用 $d_1+d_3$ 替换 $d_2$，或者用 $d_{n-1}+d_{n+1}$ 替换 $d_n$。

[AC 代码提交记录](https://www.luogu.com.cn/record/126957352)

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int MAXN=1e5+5;
int n, k, pre[MAXN], nxt[MAXN];
ll x[MAXN], val[MAXN], ans;
bool vis[MAXN];

struct node {
	int id;
	long long val;
	bool operator < (const node &x) const
	{
		return val > x.val;
	}
};

priority_queue <node> q;

void del(int id)
{
	vis[pre[id]] = vis[nxt[id]] = true;
	pre[id] = pre[pre[id]];
	nxt[id] = nxt[nxt[id]];
	pre[nxt[id]] = id;
	nxt[pre[id]] = id;
}

int main()
{
//	freopen("P3620_2.in", "r", stdin);
	cin >> n >> k;
	for (int i = 1; i <= n; ++i) { cin >> x[i]; }
	for (int i = 2; i <= n; ++i) {
		pre[i] = i-1;
		nxt[i] = i+1;
		val[i] = x[i] - x[i-1];
		q.push( (node){i, val[i]} );
	}
	val[1] = val[n+1] = 0x3f3f3f3f;
	for (int i = 1; i <= k; ++i) {
		while (vis[q.top().id]) { q.pop(); }
		node c = q.top(); q.pop();
		ans += c.val;
		val[c.id] = val[pre[c.id]] + val[nxt[c.id]] - val[c.id];
		q.push( (node){c.id,val[c.id]} );
		del(c.id);
	}
	cout << ans << endl; return 0;
}
```
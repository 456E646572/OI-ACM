---
tags:
  - 碎片
  - OI
  - OI/反悔贪心
  - OI/堆
---
## [CF730I Olympiad in Programming and Sports](https://www.luogu.com.cn/problem/CF730I)

先把编程能力最大的 $p$ 个人丢到编程团队中，然后通过反悔贪心修改选择。
有两种情况：

- 有一个新人，加入了体育团队；
- 有一个原来在编程团队中的人，加入了体育团队，然后从新人中挑了一个加入编程团队。

因此需要维护 3 个堆（下文用 $q.top().x$ 表示堆顶表示的人的能力值）：

- 用 $q_1$、$q_2$ 分别维护 **【新人】** 的编程能力 $a_i$ 和体育能力 $b_i$；
- 用 $q_3$ 维护 **【已经加入编程团队的人】** 通过反悔加入体育团队后对答案的修改量 $b_i-a_i$。

在每次选择开始前，先确定堆中的人员是否有变动，比如 $q_1$、$q_2$ 中的人有没有加入任一团队、$q_3$ 中的人有没有反悔加入体育团队。

比较上文所说两种选择对应对答案的贡献 【 $q_2.top().x$ 】 和 【 $q1.top().x+q3.top().x$ 】，取较大者计入答案后更改人员所属队伍即可。

[AC 代码提交记录](https://www.luogu.com.cn/record/127373390)

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN=3005;
int n, p, s, a[MAXN], b[MAXN], team[MAXN], ans;

struct node {
	int x, id;
	bool operator < (const node &a) const
	{
		return x < a.x;
	}
};

priority_queue <node> q1, q2, q3;

int main()
{
//	freopen("CF730I_39.in", "r", stdin);
	cin >> n >> p >> s;
	for (int i = 1; i <= n; ++i) { cin >> a[i]; q1.push( {a[i],i} ); }
	
	// 将编程能力最强的人先加入队伍
	for (int i = 1; i <= p; ++i) {
		ans += q1.top().x;
		team[q1.top().id] = 1;
		q1.pop();
	}
	
	// 一开始被选上的人加入反悔堆q3，未被选上加入体育组待选堆q2
	for (int i = 1; i <= n; ++i) {
		cin >> b[i];
		if (team[i]) { q3.push( {b[i]-a[i],i} ); }
		else         { q2.push( {b[i],i}); }
	}

	// 选择体育组
	for (int i = 1; i <= s; ++i) {
		while (team[q1.top().id]) { q1.pop(); }
		while (team[q3.top().id] == 2) { q3.pop(); }
		while (team[q2.top().id]) { q2.pop(); }
		if (q2.top().x > q3.top().x+q1.top().x) {
			// 选择新人加入体育组
			ans += q2.top().x;
			team[q2.top().id] = 2;
			q2.pop();
		} else {
			// 反悔，把编程组的人拉到体育组来
			ans += q3.top().x + q1.top().x;
			team[q3.top().id] = 2; q3.pop();
			team[q1.top().id] = 1;
			q3.push( {b[q1.top().id]-a[q1.top().id],q1.top().id} ); q1.pop();
		}
	}
	
	// 输出
	cout << ans << endl;
	for (int i = 1; i <= n; ++i) { if (team[i]==1) { cout << i << " "; } }
	cout << endl;
	for (int i = 1; i <= n; ++i) { if (team[i]==2) { cout << i << " "; } }
	return 0;
}
```

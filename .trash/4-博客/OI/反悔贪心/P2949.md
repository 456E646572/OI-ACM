---
tags:
  - 碎片
  - OI
  - OI/堆
  - OI/反悔贪心
---
## [P2949 [USACO09OPEN] Work Scheduling G](https://www.luogu.com.cn/problem/P2949)

可能第一眼看到要求最值会联想到 dp，但很快就会发现，dp 的状态很难表示，而且有后效性，维度太多复杂度又吃不住，考虑贪心。
这里有两种贪心的方法。

### 解法 1：反向扫描，纯粹的贪心

把问题变一下：从某个时刻 $D_i$ 开始能够做一项任务，完成会有 $P_i$ 的收益。

这样贪心思路就很明确了，每次都挑手上能做的、收益最高的那一个任务即可，不用考虑需不需要给后面任务留时间的问题，因为后面的任务还没有开始。

当前手上收益最高的任务，可以用堆维护。

[AC 代码提交记录](https://www.luogu.com.cn/record/126659802)

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int MAXN=1e5+5;
int n;
ll ans;

struct node {
	ll d, p;
} tsk[MAXN];

priority_queue <ll, vector<ll>, less<ll> > q;

int main()
{
//	freopen("P2949_3.in", "r", stdin);
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		cin >> tsk[i].d >> tsk[i].p;
	}
	tsk[++n] = {0, 0};
	sort(tsk+1, tsk+n+1, [](node a, node b){return (a.d>b.d)||(a.d==b.d&&a.p>b.p);});
	q.push(tsk[1].p);
	ll j = tsk[1].d;
	for (int i = 2; i <= n; ++i) {
		j = min(j, tsk[i-1].d);
		while ( (!q.empty()) && (j > tsk[i].d) ) {
			ans+=q.top(); q.pop(); --j;
		}
		q.push(tsk[i].p);
	}
	cout << ans << endl;
}
```

### 解法 2：正向扫描，反悔贪心

正向扫描需要解决的最大问题就是：需不需要给后面任务留时间。比如对于这组数据：
```
4
1 5
2 3
3 7
3 4
```
最大收益是 $5+7+4=16$，在这里就是把 $i=2$ 的那一个任务放弃，把时间留给 $i=4$ 的那一个任务了。

我们可以利用反悔贪心的思想来考虑这个问题。
也就是说，讲任务按照时间从前往后排序之后，每次碰到一个任务，就先接手开干。然后考虑：

- 如果新遇到的任务和已有的任务时间不冲突，那么就接受。
- 如果冲突了，那么，和手上收益最低的那个任务比较收益谁更大，考虑用新任务替换是不是赚，并且对收益做增量更新。

这里需要维护已有任务的最低收益，可以用堆。

[AC 代码提交记录](https://www.luogu.com.cn/record/126659552)

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int MAXN=1e5+5;
int n;
long long ans;

struct node {
	ll d, p;
} tsk[MAXN];

priority_queue <ll, vector<ll>, greater<ll>> q;

int main()
{
//	freopen("P2949_3.in", "r", stdin);
	cin >> n;
	for (int i = 1; i <= n; ++i) { cin >> tsk[i].d >> tsk[i].p; }
	sort(tsk+1, tsk+n+1, [](node a, node b){return a.d<b.d;});
	for (int i = 1; i <= n; ++i) {
		if (tsk[i].d > q.size()) {
			ans += tsk[i].p;
			q.push(tsk[i].p);
		} else if (tsk[i].p > q.top()) {
			ans += tsk[i].p-q.top();
			q.pop();
			q.push(tsk[i].p);
		}
	}
	cout << ans << endl; return 0;
}
```
---
tags:
  - 碎片
  - OI
  - OI/反悔贪心
  - OI/堆
  - OI/双向链表
---
## [P1792 [国家集训队] 种树](https://www.luogu.com.cn/problem/P1792)

为了方便表述，这里用 $pre[i]$ 表示 $i$ 的上一棵树、$nxt[i]$ 表示 $i$ 的下一棵树。

看到这道题，第一眼想到的是 dp，和[打家劫舍](https://leetcode.cn/problems/Gu0c2T/)很像，但这道题额外限制了树的数量，需要 dp 方程额外增加一维，复杂度直接爆炸。

考虑贪心。
首先，每次都选择美观度最大的那一棵树，可想而知是错误的，比如下面这组数据：
```
5 2
-1 2 3 2 -1
```
最优选择是 `2+2=4`。

在这个例子中，我们用 `3` 左右的两棵美观度为 `2` 的树将其替换掉了。

可想而知：由于每次都选择了美观度最大的那棵树 $i$，那么【只用】它左边的树 $pre[i]$、或【只用】它右边的树 $nxt[i]$ 进行替换，结果都不可能是最优。
换句话说，如果一棵树 $i$ 的美观度比它左边的树 $pre[i]$ 大、也比它右边的树 $nxt[i]$ 大，在左右两棵树至少有一棵不能选的情况下，$i$ 这棵树必然在待选清单中。

**【因此，如果每次贪心地种下一棵美观度最高的树，结果只有两种：要么这棵树在最终的选择中，要么这棵树被同时替换为了左右两边两棵树。】**

考虑反悔贪心，每次都贪心地选择美观度最大的那一棵树 $i$，暂时将其加入待选清单。
接下来我们要做的事情就是，明确一种方式进行反悔，**【将选择的树 $i$ 从待选清单中移除，并将其左右两棵树 $pre[i]$ 和 $nxt[i]$ 加入待选清单】**。

这里可以做增量更新。
**【每当暂时选择了 $i$ 时，将 $i$、$pre[i]$、$nxt[i]$ 三棵树合在一起，放在 $i$ 这棵树的位置，美观度为 $A_{pre[i]}+A_{nxt[i]}-A_i$ 。】**

这样一来，如果我再次选择了 $i$ 位置上的树，两次选择的美观度之和为 $A_i+A_{pre[i]}+A_{nxt[i]}-A_i=A_{pre[i]}+A_{nxt[i]}$。这两次选择的结果也就等价于：**【没有选择 $i$，而是选择了 $pre[i]$ 和 $nxt[i]$ 】**。

就结果而言，既然现在选择了 $pre[i]$ 和 $nxt[i]$，那么 $pre[pre[i]]$、$nxt[nxt[i]]$、$i$ 这三棵树是不能选择的。

由于在上一步中，我们将 $pre[i]$、$i$、$nxt[i]$ 三棵树合成了一棵新的树 $j$，因此撇去上述三棵不能选择的树、并且保留反悔机会的操作，也就等价于：**【对于这棵新的树 $j$，将 $pre[j]$、$j$、$nxt[j]$ 三棵树合在一起，美观度为 $A_{pre[j]}+A_{nxt[j]}-A_j$ 】**。

这样一来，反悔贪心的思路就理清了：

1. 选择一棵美观度最大的树 $i$，将 $A_i$ 计入答案，计数器+1；
2. 将 $pre[i]$ 和 $nxt[i]$ 标记为不可选择；
3. 在 $i$ 的位置上放一棵假想的树 $j$，下列所有的更改，都在 $i$ 的位置上进行：
	1. 将 $j$ 的美观度 $A_j$ 更新为 $A_{pre[i]}+A_{nxt[i]}-A_i$；
	2. 更新双向链表中的 $pre[j]$、$nxt[j]$、$pre[nxt[j]]$、$nxt[pre[j]]$ 四项；
4. 重复上述三步，直到计数器达到了规定的数量 $m$，输出答案。

[AC 代码提交记录](https://www.luogu.com.cn/record/126935686)

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN=2e5+5;
int n, m, a[MAXN], ans, pre[MAXN], nxt[MAXN];
bool fbd[MAXN];

struct node {
	int id, a;
	bool operator < (const node &x) const
	{
		return a < x.a;
	}
};

priority_queue <node> q;

void del(int id)
{
	fbd[pre[id]] = fbd[nxt[id]] = true;
	pre[id] = pre[pre[id]];
	nxt[id] = nxt[nxt[id]];
	nxt[pre[id]] = id;
	pre[nxt[id]] = id;
}

int main()
{
//	freopen("P1792_1.in", "r", stdin);
	cin >> n >> m;
	if (n < 2*m) { cout << "Error!" << endl; return 0; }
	for (int i = 1; i <= n; ++i) {
		cin >> a[i];
		q.push( (node){i,a[i]} );
		pre[i] = (i==1? n: i-1);
		nxt[i] = (i==n? 1: i+1);
	}
	for (int i = 1; i <= m; ++i) {
		while (fbd[q.top().id]) { q.pop(); }
		node c = q.top(); q.pop();
		ans += c.a;
		a[c.id] = a[pre[c.id]] + a[nxt[c.id]] - a[c.id];
		q.push( (node){c.id, a[c.id]} );
		del(c.id);
	}
	cout << ans << endl;
}
```

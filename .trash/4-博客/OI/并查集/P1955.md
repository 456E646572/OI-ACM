---
tags:
  - 碎片
  - OI
  - OI/并查集
  - OI/离散化
---
## [P1955 [NOI2015] 程序自动分析](https://www.luogu.com.cn/problem/P1955)

先做 $e=1$ 的约束条件，再判断 $e=0$ 的那些条件是否满足。

由于值域较大，需要离散化。

[AC 代码提交记录](https://www.luogu.com.cn/record/128972616)

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN=1e5+5;
int t, f[MAXN<<1], id_to_ij[MAXN<<1], cp0, cp1, cnt;

struct node {
	int x, y;
} p0[MAXN], p1[MAXN];

int find(int x)
{
	return f[x]==x? x: f[x]=find(f[x]);
}

void ij_to_id(int &x)
{
	x = lower_bound(id_to_ij+1, id_to_ij+cnt+1, x)-id_to_ij;
}

int main()
{
//	freopen("P1955_2.in", "r", stdin);
	cin >> t;
	while (t--) {
		cp0 = cp1 = cnt = 0;
		int n; cin >> n;
		for (int i = 1; i <= 2*n; ++i) { f[i] = i; }
		for (int i = 1; i <= n; ++i) {
			int x, y, e;
			cin >> x >> y >> e;
			id_to_ij[++cnt] = x;
			id_to_ij[++cnt] = y;
			if (e == 0) { p0[++cp0] = { x, y }; }
			else        { p1[++cp1] = { x, y }; }
		}
		sort(id_to_ij+1, id_to_ij+cnt+1);
		cnt=unique(id_to_ij+1, id_to_ij+cnt+1)-id_to_ij-1;
		for (int i = 1; i <= cp1; ++i) {
			int x=p1[i].x, y=p1[i].y;
			ij_to_id(x);
			ij_to_id(y);
			if (find(x) != find(y)) { f[find(x)] = find(y); }
		}
		bool ava=true;
		for (int i = 1; i <= cp0; ++i) {
			int x=p0[i].x, y=p0[i].y;
			ij_to_id(x);
			ij_to_id(y);
			if (find(x) == find(y)) { ava=false; cout << "NO" << endl; break; }
		}
		if (ava) { cout << "YES" << endl; }
	}
	return 0;
}
```
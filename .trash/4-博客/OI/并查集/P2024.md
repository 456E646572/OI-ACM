---
tags:
  - 碎片
  - OI/并查集
  - OI/种类并查集
---
## [P2024 [NOI2001] 食物链](https://www.luogu.com.cn/problem/P2024)

在并查集中，我们通过指定 `组长` 的方式来规定一个组，把成员当做了一个明确的类别，也就决定了普通的并查集只能维护 `朋友的朋友是朋友`，即谁和谁是一类的，而不能维护 `敌人的敌人` 这层关系。

想要维护 `敌人的敌人` 这层关系，可以使用种类并查集。

我们可以独立放置一个假想的敌人，用这个假想的敌人在并查集中 `明确一个类别`，进而维护住答案。

具体而言，设 $find(x)$ 是并查集查找的结果。如果一个动物的编号是 $A$，我们定义编号为 $A+n$ 的动物是 $A$ 的食物，而 $A+2n$ 的动物是 $A$ 的天敌。每当遇到一句结论 `a x y`：

- 如果 $find(x)=find(y)$，则两者是朋友关系；
- 如果 $find(x+n)=find(y)$，即 $y$ 和 $x$ 的食物是一类，即 $x$ 捕食 $y$；
- 如果 $find(x)=find(y+n)$，同理，是 $y$ 捕食 $x$。

按照这种维护方式遍历所有结论 `a x y` 即可，记得特判。

[AC 代码提交记录](https://www.luogu.com.cn/record/128836221)

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN=5e4+5, MAXK=1e5+5;
int n, k, f[MAXN<<2], ans;

int find(int x)
{
	return f[x]==x? x: find(f[x]);
}

int main()
{
	cin >> n >> k;
	for (int i = 1; i <= 3*n; ++i) {
		f[i] = i;
	}
	for (int i = 1; i <= k; ++i) {
		int a, x, y;
		cin >> a >> x >> y;
		if (x>n || y>n) {
			++ans; continue;
		}
		if (a == 1) {
			if (find(x)==find(y+n) || find(x+n)==find(y)) { ++ans; }
			else {
				f[find(x)]     = find(y);
				f[find(x+n)]   = find(y+n);
				f[find(x+2*n)] = find(y+2*n);
			}
		} else {
			if (x==y || find(x)==find(y) || find(y+n)==find(x)) { ++ans; }
			else {
				f[find(x+n)]   = find(y);
				f[find(x+2*n)] = find(y+n);
				f[find(x)]     = find(y+2*n);
			}
		}
	}
	cout << ans << endl;
	return 0;
}
```

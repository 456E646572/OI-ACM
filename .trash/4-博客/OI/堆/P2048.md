---
tags:
  - 碎片
  - OI
  - OI/堆
  - OI/RMQ
---
## [P2048 [NOI2010] 超级钢琴](https://www.luogu.com.cn/problem/P2048)

要求长度在 $[L,R]$ 的前 $k$ 个最大连续子段和（超级和弦）之和，总的数量是 $O(n^2)$，如果暴力枚举，可以使用前缀和优化，再用堆维护现在前 $k$ 大超级和弦中的最小值，打擂台，时间复杂度 $O(n^2log k)$。

想要优化，就必然不能把 $O(n^2)$ 种情况全部枚举一遍。可以类比 [[iai433]] 的做法，**对于一类超级和弦，只将最大的那一个加入堆中，每当从堆中取出一个超级和弦时，再将次大的超级和弦加入。**

具体而言，假设我此时考虑的超级和弦起点为 $st$，终点 $ed$ 的取值范围为 $[st+L-1, st+R-1]$。不妨设该区间为 $[l,r]$，于是我们可以用一个三元组 $(st,l,r)$ 描述以 $st$ 为起点，终点 $ed$ 范围在 $[l,r]$ 的超级和弦。

这样一来，设前缀和数组为 $s[i]$，这段超级和弦的美妙度可以用前缀和描述为 $s[ed]-s[st-1]$，由于左端点固定，当 $s[ed]$ 取到最大值（设该位置为 $t$）时，这段超级和弦的美妙度也取到了最大值，即 $s[t]-s[st-1]$。而这个求 $t$ 和 $s[t]$ 的步骤，可以使用 ST 表在 $O(1)$ 的时间内完成。

接下来，对于这一类超级和弦 $(st,l,r)$，要取它们中的次大值。

可想而知的是，区间 $[l,r]$ 内的最大值 $s[t]$ 已经被取掉，次大值只能在区间 $[l,t)\cup(t,r]$ 中。于是此时，我们可以将 $(st,l,t-1)$ 和 $(st,t+1,r)$ 加入堆中，进而将【求次大值】转化为与【求最大值】同构的子问题（注意特判 $l>t-1$ 和 $t+1>r$ 的情况）。

由题意得，我们需要从堆中恰好取出 $k$ 段超级和弦，而每次取出后，至多只会往堆中加入 $2$ 段新的超级和弦，于是堆的大小规模为 $O(2k)=O(k)$。不会爆空间。

整体的流程如下：

1. 对于输入的美妙度 $a[i]$，求其前缀和 $s[i]$，时间复杂度 $O(n)$；
2. 对前缀和数组 $s[i]$ 建立 ST 表，预处理时间复杂度 $(n\log n)$；
3. 将所有超级和弦按照起点分类，以三元组 $(st,l,r)$ 的形式加入堆中，时间复杂度 $O(n \log n)$；
4. 从堆中取出美妙度最大的超级和弦，将美妙度 $s[t]$ 累加计入答案，将次小值可能在的两个区间以三元组 $(st,l,t-1)$ 和 $(st,t+1,r)$ 的形式加入堆中，重复，直到累计取出 $k$ 段超级和弦为止，时间复杂度 $O(k\log k)$；
5. 输出答案。总时间复杂度 $O(n\log n+k\log k)$

[AC 代码提交记录](https://www.luogu.com.cn/record/127474014)

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int MAXN=5e5+5, MAXI=20;
int n, k, L, R, p[MAXN][MAXI+5];
ll a[MAXN], s[MAXN][MAXI+5], ans;

pair<ll,int> query(int l, int r)
{
	int i = log2(r-l+1);
	ll  lv=s[l][i], rv=s[r-(1<<i)+1][i];
	int lp=p[l][i], rp=p[r-(1<<i)+1][i];
	if (lv < rv) { return make_pair(rv,rp); }
	else         { return make_pair(lv,lp); }
}

struct node {
	int st, l, r, p;
	ll x;
	bool operator < (const node &c) const {
		return x < c.x;
	}
};

node new_node(int st, int l, int r)
{
	int pos; ll val;
	tie(val,pos) = query(l,r);
	return (node){ st, l, r, pos, val-s[st-1][0] };
}

priority_queue <node> q;

int main()
{
	cin >> n >> k >> L >> R;
	for (int i = 1; i <= n; ++i) {
		cin >> a[i];
		s[i][0] = s[i-1][0] + a[i];
		p[i][0] = i;
	}

	// 建立st表
	for (int i = 1; i <= MAXI; ++i) {
		for (int j = 1; j+(1<<(i-1)) <= n; ++j) {
			ll  lv=s[j][i-1], rv=s[j+(1<<(i-1))][i-1];
			int lp=p[j][i-1], rp=p[j+(1<<(i-1))][i-1];
			if (lv < rv) { s[j][i]=rv; p[j][i]=rp; }
			else         { s[j][i]=lv; p[j][i]=lp; }
		}
	}

	// 建堆
	for (int i=1, l=i+L-1, r=i+R-1; l <= n; ++i, ++l, ++r) {
		r = min(n, r);
		q.push( new_node(i,l,r) );
	}

	// 选取前k个
	for (int i = 1; i <= k; ++i) {
		node c = q.top(); q.pop();
		ans += c.x;
		if (c.l <= c.p-1) { q.push( new_node(c.st, c.l, c.p-1) ); }
		if (c.p+1 <= c.r) { q.push( new_node(c.st, c.p+1, c.r) ); }
	}

	// E.D.
	cout << ans << endl;
	return 0;
}
```
---
tags:
  - 碎片
  - OI
  - OI/堆
---
## [P7072 [CSP-J2020] 直播获奖](https://www.luogu.com.cn/problem/P7072)

$k\%$ 位数问题，是堆的一个经典应用。

解法是对顶堆：开一个大根堆 `q` 和一个小根堆 `p`，大根堆存小数字，小根堆存大数字，并且保证总数为奇数时，小根堆的大小恰好为 $p\times w\%$。

每当考虑一个新的数字 $a$ 时，做两步：

- 因为大根堆要存小数字，所以先拿 $a$ 和 `q.top()` 进行比较，来决定加入哪个堆中。
- 再调整小根堆的大小，小根堆多就把多出来的数字丢到大根堆，少就从大根堆里弹出堆顶补充。

题目中所求的答案即为小根堆堆顶。

比如对于这组数据：`5, 6, 1, 2, 7, 4, 1`、$w=50$。
假设我们已经知道了前五个数的 $50\%$ 位数是 `5`。
则现在大根堆中的数据：`2, 1`，小根堆中的数据为 `5, 6, 7`。

处理接下来一个数字 `4`，在这里，因为 `4` 比大根堆堆顶 `2` 大，所以加入小根堆。
现在小根堆中有 4 个数字：`4, 5, 6, 7`，而 $p\times w\%=3$，所以把小根堆堆顶 4 弹出，放到大根堆。
现在大根堆中的数据：`4, 2, 1`，小根堆中的数据为 `5, 6, 7`，输出答案 `5`。

再处理接下来一个数字 `1`，比大根堆堆顶 `4` 小，所以加入大根堆
现在大根堆中的数据：`4, 2, 1, 1`，小根堆中的数据为 `5, 6, 7`，$p\times w\%=4$。
调整大小，把大根堆堆顶 `4` 弹出放入小根堆。
现在大根堆中的数据：`2, 1, 1`，小根堆中的数据为 `4, 5, 6, 7`，输出答案 `4`。

实现方面，只需要用两个 `priority_queue` 即可。

[AC 代码提交记录](https://www.luogu.com.cn/record/126651174)
```cpp
#include <bits/stdc++.h>

using namespace std;

int n, w;
priority_queue <int> q;
priority_queue <int, vector<int>, greater<int>> p;

int main()
{
	cin >> n >> w;
	for (int i = 1; i <= n; ++i) {
		int x, k=max(1, i*w/100);
		cin >> x;
		if (q.empty() || x > q.top()) {
			p.push(x);
		} else {
			q.push(x);
		}
		while (!p.empty() && p.size() > k) { q.push(p.top()); p.pop(); }
		while (!p.empty() && p.size() < k) { p.push(q.top()); q.pop(); }
		cout << p.top() << " ";
	}
	return 0;
}
```

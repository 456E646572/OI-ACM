---
tags:
  - 碎片
  - OI
  - OI/堆
  - OI/扫描线
  - OI/懒思想
---
## [P2061 [USACO07OPEN] City Horizon S](https://www.luogu.com.cn/problem/P2061)

矩形面积并，一眼【扫描线】。

从左往右，在有建筑开始或结束的地方，放一条假想的、垂直于地平线的【扫描线】，对合并完之后的那个奇形怪状的图形做切割。
![[P2061例子]]
这样一来，每次切割出来的部分是一个矩形。面积可以拿相邻两条扫描线的距离差 $\Delta x$，乘上这段里面的高度最大值 $h_{max}$。答案是这 $2n$ 条扫描线切割出来的面积之和，即 $S=\sum(\Delta x\times h_{max})$。

因为扫描线是人为定下来的，$\Delta x$ 很好求，难点在于如何维护 $h_{max}$。二维平面上的扫描线需要用到线段树，但在这里，因为题干中有地平线的存在，只需要拿一个堆即可。

假设我们已经维护出了前 $i$ 条扫描线 $bd_i$，对于第 $i+1$ 条扫描线 $bd_{i+1}$：

- 两条扫描线之间的距离差为 $\Delta x=bd_{i+1}.x-bd_i.x$，从堆中取出 $h_{max}$，将 $\Delta x\times h_{max}$ 计入答案。
- 如果这条扫描线标记了某一幢建筑的【起点】，那么将这幢建筑的高度加入堆中。
- 如果这条扫描线标记了某一幢建筑的【终点】，那么执行删除操作。

接下来介绍堆的删除操作：【懒删除】。

因为在堆中，我们只能很快知道堆顶的元素，对于具体元素的位置需要遍历整个堆，时间吃不住。

但是，我们可以发现，如果被删去的元素不在堆顶，那么将不会从堆中取出被删去的元素，进而也就不会对答案产生影响。

所以我们可以用 `flag` 数组，或者 `cnt` 数组，或者再开一个堆，记下所有要删除的元素。
每次从堆中取出元素时，检查它是否被删除，然后才真正执行删除操作。

当然，在这题中，可以比较当前扫描线的位置，和取出的高度所代表的这幢楼的终点的位置，也可以判断取出的 $h_{max}$ 是否合法。

[AC 代码提交记录](https://www.luogu.com.cn/record/126661468)

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int MAXN=4e4+5;
int n;
ll ans;

struct node {
	ll x, h;
	bool st;
} bd[MAXN<<1];

priority_queue <ll> q, del_q;

int main()
{
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		long long a, b, h; cin >> a >> b >> h;
		bd[2*i-1] = { a, h, 1 };
		bd[2*i]   = { b, h, 0 };
	}
	sort(bd+1, bd+2*n+1, [](node a, node b){return a.x<b.x;});
	for (int i = 1; i <= 2*n; ++i) {
		while ( (!q.empty()) && (!del_q.empty()) && (q.top() == del_q.top())) { q.pop(); del_q.pop(); }
		if (!q.empty()) { ans += q.top() * (bd[i].x-bd[i-1].x); }
		if (bd[i].st) { q.push(bd[i].h); }
		else            { del_q.push(bd[i].h); }
	}
	cout << ans << endl;
}
```

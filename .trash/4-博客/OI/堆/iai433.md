---
tags:
  - 碎片
  - OI
  - OI/堆
  - OI/blah数集
---
## [iai433 分数排序](https://iai.sh.cn/problem/433)

$\displaystyle\frac ab$ 是最简真分数，等价于 $a,b$ 互质，等价于 $\gcd(a,b)=1$。

把所有分数都罗列出来，复杂度是平方级别的，显然吃不住，只能拿 60 分，所以只能从小到大一个一个看。

- 如果分母相同，分子越小，分数越小。
- 如果分子相同，分母越大，分数越小。
- 如果分子分母都不相同，就没办法快速比较了。

所以这里可以用堆维护最小的分数，相同分母的分数，只要选最小的那个加入堆即可。

初始时，堆中有 $n-1$ 个元素，分别为 $\displaystyle\frac12, \frac13, \cdots, \frac1n$。每次取出最小的那一个 $\displaystyle\frac ab$，然后考虑下一个以 $b$ 为分母的分数 $\displaystyle\frac{a+1}{b}$，如果是最简真分数就入堆，不合法就再枚举下一个。

[AC代码提交记录](https://iai.sh.cn/submission/776240)

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXK=2e5+5;
int n, k, cnt;

struct node {
	int a, b;
	double a_b;
	bool operator <(const node &x) const
	{
		return a_b > x.a_b;
	}
} num;

priority_queue <node> q;

int main()
{
	cin >> n >> k;
	for (int i = 2; i <= n; ++i) { q.push({1, i, double(1)/i}); }
	node c;
	for (int i = 1; i <= k; ++i) {
		c=q.top(); q.pop();
		int a = c.a + 1;
		while ( (a < c.b) && (__gcd(a,c.b)!=1) ) { ++a; }
		q.push( {a, c.b, double(a)/c.b} );
	}
	cout << c.a << "/" << c.b << endl; return 0;
}
```
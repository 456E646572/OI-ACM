---
tags:
  - 碎片
  - OI/分块
  - OI/懒思想
---
## [P3870 [TJOI2009] 开关](https://www.luogu.com.cn/problem/P3870)

这道题用来介绍分块的基本操作。

首先题意非常明确，需要维护区间求和、区间取反两种操作，暴力修改查询的话，单次需要 $O(n)$。

我们可以将 $sz$ 个连续的灯划为一个块。

为什么要分块呢？

设 $cnt$ 表示某时刻亮着的灯的数量，即答案。对所有灯进行一次取反操作，此时的答案可以很快维护出来，即 $cnt\leftarrow n-cnt$，而维护的过程并没有做单点修改，打个懒标记记录一下即可。

推广一下，对于一段固定的区间 $[L,R]$，我们可以记录下这段区间的大小 $k$ 和答案 $cnt_i$，在对整块操作时，令 $cnt_i\leftarrow k-cnt_i$，再打上懒标记，在 $O(1)$ 的时间内将答案维护出来，节约时间。**也就是说，整块相较一个一个单点修改，有较优的方式维护，而剩下的散点则可以用相对暴力的方式维护。** 通过分块，我们就可以利用这一较优的维护方式。

但这种做法是有问题的。首先，这段区间 $[L,R]$ 的长度不能太小，这样才能起到优化时间的作用，否则相当于一个一个单点修改。可是，一旦区间长度增大，那么单次修改【整个】区间的可能性就随之降低。**也就是说，整块长度越大，优化时间越多，但优化到的概率却越低。**

![[0-系统组件/1-Excalidraw/P3870]]

为了在【优化时间】和【优化概率】之间达到平衡，我们设单个块的大小为 $sz$，共有 $\displaystyle k=\lceil\frac{n}{sz}\rceil$ 个块，接下来，我们需要通过计算确定具体的取值。

考虑单次修改的时间复杂度。我们最多对 $k$ 个块进行整块的操作，而整块修改单次 $O(1)$；最多对 $2\times sz$ 个单点下传懒标记并进行暴力修改，时间复杂度 $O(sz)$。单次修改总时间复杂度 $O(k+sz)$。查询时同理。

设修改次数为 $n$，于是总的时间复杂度为：$\displaystyle O(n\times sz+\frac{n^2}{sz})$，当 $\displaystyle n\times sz=\frac{n^2}{sz}\Rightarrow n=\sqrt n$ 时有最小时间复杂度 $O(n\sqrt n)$。这个复杂度相当优秀，加上分块常数较小，可以和 $O(n\log^2 n)$ 甚至 $O(n\log n)$ 的算法媲美。

总结一下分块的思路：

- 针对题目中要求的操作，找到一种节约时间的整块维护方式；
- 计算复杂度，推导 $sz$ 的取值，在【优化时间】和【优化概率】之间达到平衡；
- 对单点和整块分开处理。

具体实现见代码，主要关注【如何分块】、【如何在操作时区分单点和整块】。

[AC 代码提交记录](https://www.luogu.com.cn/record/103294603)

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN=1e5+5, MAXK=355;
int n, m, k, L[MAXK], R[MAXK], belong[MAXN];
int cnt[MAXK], tag[MAXK], status[MAXN];

void modify(int a, int b)
{
	// a、b在一个块内，直接暴力修改
	if (belong[a] == belong[b]) {
		for (int i = a; i <= b; ++i) {
			status[i]^=1, cnt[belong[i]]+=(status[i]^tag[belong[i]]?1:-1);
		}
		return;
	}
	
	// a往后不满一个块
	int l=L[belong[a]], r=R[belong[a]];
	while ( (l<a) && (a<=r) ) {
		status[a]^=1, cnt[belong[a]]+=(status[a]^tag[belong[a]]?1:-1), ++a;
	}
	
	// b往前不满一个块
	l=L[belong[b]], r=R[belong[b]];
	while ( (l<=b) && (b<r) ) {
		status[b]^=1, cnt[belong[b]]+=(status[b]^tag[belong[b]]?1:-1), --b;
	}
	
	// 整块处理
	for (int i = belong[a]; i <= belong[b]; ++i) {
		tag[i]^=1, cnt[i]=R[i]-L[i]+1-cnt[i];
	}
}

int query(int a, int b)
{
	int res=0;
	
	// a、b在一个块内，直接暴力修改
	if (belong[a] == belong[b]) {
		for (int i = a; i <= b; ++i) {
			res += status[i]^tag[belong[i]];
		}
		return res;
	}
	
	// a往后不满一个块
	int l=L[belong[a]], r=R[belong[a]];
	while ( (l<a) && (a<=r) ) {
		res+=status[a]^tag[belong[a]], ++a;
	}
	
	// b往前不满一个块
	l=L[belong[b]], r=R[belong[b]];
	while ( (l<=b) && (b<r) ) {
		res += status[b]^tag[belong[b]], --b;
	}
	
	// 整块处理
	for (int i = belong[a]; i <= belong[b]; ++i) {
		res += cnt[i];
	}
	
	return res;
}

int main()
{
	cin.tie(nullptr) -> sync_with_stdio(false);

	// I.N.
	cin >> n >> m;
	
	// init
	k = sqrt(n);
	for (int i = 1; i <= k; ++i) {
		L[i]=(i-1)*k+1, R[i]=i*k;
		for (int j = L[i]; j <= R[i]; ++j) { belong[j]=i; }
	}
	if (R[k] < n) {
		++k, L[k]=R[k-1]+1, R[k]=n;
		for (int j = L[k]; j <= R[k]; ++j) { belong[j]=k; }
	}
	
	//
	while (m--) {
		int c, a, b;
		cin >> c >> a >> b;
		if (c == 0) {
			modify(a, b);
		} else {
			cout << query(a, b) << endl;
		}
	}
	
	// E.D.
	return 0;
}
```

---
tags:
  - 碎片
  - OI/分块
---
## [P3203 [HNOI2010] 弹飞绵羊](https://www.luogu.com.cn/problem/P3203)

这题其实把思路讲出来就很简单了，但初看真的想不到。

首先最原始的做法就是暴力，一个一个跳，单次查询复杂度 $O(ans)$。

但这很明显太慢了，优化思路是，如果没有修改操作，弹飞的路径是固定的，完全可以将一段弹力装置放在一起处理，或者说，把某一段弹力装置压缩变成一个超级弹力装置。

![[0-系统组件/1-Excalidraw/P3203]]

在没有修改的情况下，我们自然而然地就会想到，把所有弹力装置从头到尾压缩在一起。但加上了修改，情况就不一样了。重新计算超级弹力装置的时间是 $O(sz)$，其中 $sz$ 表示这个超级弹力装置压缩了几个弹力装置。如果把所有弹簧压缩在一起，这个修改成本是非常高的。

整块有利于查询操作，单点有利于修改操作。于是考虑分块。

设块的大小为 $sz$，共有 $k=\displaystyle\frac{n}{sz}$ 个块。

查询时，至多经历 $k$ 个块，单次复杂度 $O(1)$，总时间复杂度 $O(k)$。

修改时，重新计算这个块，算出在不同位置进入这个块所对应的弹出位置，单次复杂度 $O(sz)$，一次只修改一个弹力值，同时重新计算它所在的块，总复杂度 $O(sz)$。

共 $m$ 次操作，总时间复杂度 $\displaystyle O(m(sz+\frac{n}{sz}))$，当 $sz=\sqrt n$ 时有复杂度最小值 $O(m\sqrt n)$。

最后，本题和 [CF13E](https://www.luogu.com.cn/problem/CF13E) 重复，双倍经验。

[AC 代码提交记录](https://www.luogu.com.cn/record/103683504)

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN=2e5+5, MAXK=450;
int n, m, k, a[MAXN], L[MAXK], R[MAXK], belong[MAXN], arr[MAXN], cnt[MAXN];

void update(int block, int ith)
{
	arr[ith] = (ith+a[ith]>R[block]? ith: arr[ith+a[ith]]);
	cnt[ith] = (ith+a[ith]>R[block]? 0: cnt[ith+a[ith]]+1);
}

void init()
{
	k = sqrt(n);
	for (int i = 1; i <= k; ++i) {
		L[i]=(i-1)*k+1, R[i]=i*k;
	}
	if (R[k] < n) {
		++k, L[k]=R[k-1]+1, R[k]=n;
	}
	for (int i = k; i; --i) {
		for (int j = R[i]; j >= L[i]; --j) {
			belong[j]=i;
			update(i, j);
		}
	}
	
}

void modify(int x, int y)
{
	a[x] = y;
	for (int i = x; i >= L[belong[x]]; --i) {
		update(belong[x], i);
	}
}

int query(int x)
{
	int res=0;
	while (x <= n) {
		res+=cnt[x], x=arr[x];
		x=x+a[x], ++res;
	}
	return res;
}

int main()
{
	// cin.tie(nullptr) -> sync_with_stdio(false);

	// I.N.
	cin >> n;
	for (int i = 1; i <= n; ++i) { scanf("%d", &a[i]); }
	
	// 预处理分块信息
	init();
	
	// O.P.
	scanf("%d", &m);
	while (m--) {
		int op, x, y;
		scanf("%d%d", &op, &x), ++x;
		if (op == 1) {
			printf("%d\n", query(x));
		} else {
			scanf("%d", &y);
			modify(x, y);
		}
	}
	
	// E.D.
	return 0;
}
```
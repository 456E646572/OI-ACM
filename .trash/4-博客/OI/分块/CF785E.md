---
tags:
  - 碎片
  - OI/分块
---
## [Anton and Permutation](https://www.luogu.com.cn/problem/CF785E)

这里介绍一下动态逆序对的分块做法。

设块的大小为 $k$，则块的数量为 $\displaystyle\frac{n}{k}$。设 `query(l+1,r-1,v)` 表示区间 $[l+1,r-1]$ 中严格小于 $v$ 的数的个数。

接下来我们讨论交换 $n_1$、$n_2$ 后对答案的贡献：

为了方便表述，这里设 $[l+1,r-1]$ 中的任意一个数是 $a$。

当 $n_1$ 往后移动时，若移动前 $(n_1,a)$ 是逆序对，则该逆序对被消除，即 `ans += -query(l+1,r-1,n_1)`；若移动前 $(n_1,a)$ 不是逆序对，则 $(a,n_1)$ 是逆序对，即 `ans += (r-l-1)-query(l+1,r-1,n_1)`。

同理，当 $n_2$ 往前移动时，`ans += query(l+1,r-1,n_2)`，`ans += -(r-l-1)+query(l+1,r-1,n_2)`。

最后，若 $(n_1,n_2)$ 是一个逆序对，则交换后被消除，`--ans`，否则 `++ans`。

具体实现时，块内排序做二分即可。`query()` 的时间复杂度 $\displaystyle O(k + \frac{n\log{k}}{k})$；`update()` 的时间复杂度 $O(k)$；`modify()` 的时间复杂度 $\displaystyle O( n \times (k + \frac{n\log n}{k}) )$。块长取 $k=\sqrt{n\log n}$。

[AC 代码提交记录](https://www.luogu.com.cn/record/104248344)

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN=2e5+5, MAXK=2000;
int n, a[MAXN], b[MAXN], q;
long long ans;
int k, sz, L[MAXK], R[MAXK], belong[MAXN];
int num_to_aid[MAXN], num_to_bid[MAXN];

inline int read()
{
    int ret=0;
    int f=1;
    char c=getchar();
    while(c<'0' || c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0' && c<='9'){
        ret=ret*10+c-'0';
        c=getchar();
    }
    return ret*f;
}

inline void init()
{
	// 初始化原序列
	for (int i = 1; i <= n; ++i) { a[i]=b[i]=i, num_to_aid[i]=num_to_bid[i]=i; }
	
	// 分块
	k=sqrt(n*log2(n)), k=(k==0? 1: k);
	// k = sqrt(n);
	sz = n/k;
	for (int i = 1; i <= sz; ++i) {
		L[i]=(i-1)*k+1, R[i]=i*k;
	}
	if (R[sz] < n) {
		++sz, L[sz]=R[sz-1]+1, R[sz]=n;
	}
	for (int i = 1; i <= sz; ++i) {
		for (int j = L[i]; j <= R[i]; ++j) {
			belong[j] = i;
		}
	}
}

inline long long query(int l, int r, int v)
{
	// 求[l,r]区间内比v小的数的个数
	if (l>r) { return 0; }
	long long res=0;
	if (belong[l] == belong[r]) {
		for (int i = l; i <= r; ++i) {
			res += (a[i]<v);
		}
		return res;
	}
	while ( (L[belong[l]]<l) && (l<=R[belong[l]])) { res+=(a[l]<v), ++l; }
	while ( (L[belong[r]]<=r) && (r<R[belong[r]])) { res+=(a[r]<v), --r; }
	for (int i = belong[l]; i <= belong[r]; ++i) {
		res += upper_bound(b+L[i],b+R[i]+1,v)-(b+L[i]);
	}
	return res;
}

inline void update(int x, int bid)
{
	while ( (L[belong[bid]]<bid) && (b[bid-1]>x) ) {
		swap(b[bid-1], b[bid]);
		swap(num_to_bid[b[bid-1]], num_to_bid[b[bid]]);
		--bid;
	}
	while ( (bid<R[belong[bid]]) && (x>b[bid+1]) ) {
		swap(b[bid], b[bid+1]);
		swap(num_to_bid[b[bid]], num_to_bid[b[bid+1]]);
		++bid;
	}
}

inline void modify(int n_1, int n_2)
{
	// 保证n_1在n_2左侧
	int l=num_to_aid[n_1], r=num_to_aid[n_2];
	if (l>r) { swap(l,r), swap(n_1,n_2); }
	
	// 更新答案
	ans += (
		2*query(l+1,r-1,n_2)-2*query(l+1,r-1,n_1)
		+ (n_1<n_2? 1: -1)
	);
	
	// 交换
	swap(a[num_to_aid[n_1]], a[num_to_aid[n_2]]);
	swap(num_to_aid[n_1], num_to_aid[n_2]);
	
	if (belong[num_to_bid[n_1]] != belong[num_to_bid[n_2]]) {
		swap(b[num_to_bid[n_1]], b[num_to_bid[n_2]]);
		swap(num_to_bid[n_1], num_to_bid[n_2]);
		update(n_1, num_to_bid[n_1]);
		update(n_2, num_to_bid[n_2]);
	}
}

int main()
{
	// cin.tie(nullptr) -> sync_with_stdio(false);

	// I.N.
	n=read(), q=read();
	
	// 初始化
	init();
	
	// O.P.
	while (q--) {
		int n_1, n_2;
		n_1=read(), n_2=read();
		if (n_1 == n_2) {
			printf("%lld\n", ans); continue;
		}
		modify(n_1, n_2);
		printf("%lld\n", ans);
	}
	
	// E.D.
	return 0;
}
```
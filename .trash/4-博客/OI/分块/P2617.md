---
tags:
  - 碎片
  - OI/分块
---
## [P2617 Dynamic Rankings](https://www.luogu.com.cn/problem/P2617)

这里介绍一下动态第 $k$ 大问题的分块做法。

和线段树一样，分块的特点，是易于处理**区间可加性问题**。但很多时候，在有限时空限制内无法转化为区间可加性问题的，我们不必将思路局限于此。比如区间众数问题（[P4168 [Violet] 蒲公英]）就需要换一种储存方式，储存数字出现的下标，而不用桶直接做哈希，避免使用区间相加的方式求出答案。

除此之外，分块还可以在分完的块内进行排序操作，以维护有序性，便于调用（[Acwing252 磁力块](https://www.acwing.com/problem/content/252/)）。

在这里，将两个想法相结合，就可以得到本题的正解。

首先，动态第 $k$ 大问题显然不能转化为区间可加性问题，不用想着开个桶死磕什么的（好像有对值域分块的做法，但我不会 qwq）。我们对序列分块，将块内排序后二分答案 $x$，每次验证答案时利用块内有序性，快速求出比 $x$ 小的元素个数，把多个块的答案相加，就能得到 $x$ 的排序。

块长取 $\sqrt n$ 即可，不开 O2 也可以在 2.8 秒左右通过最大的测试点。

[AC 代码提交记录](https://www.luogu.com.cn/record/133544138)

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN=1e5+5, MAXK=355;
int n, q, a[MAXN];
vector <int> arr(MAXN);
int k, sz, L[MAXK], R[MAXK], belong[MAXN];

void init()
{
	// 分块信息
	k=sqrt(n), sz=n/k;
	for (int i = 1; i <= k; ++i) {
		L[i]=(i-1)*sz+1, R[i]=i*sz;
	}
	if (R[k] < n) {
		++k, L[k]=R[k-1]+1, R[k]=n;
	}
	for (int i = 1; i <= k; ++i) {
		for (int j = L[i]; j <= R[i]; ++j) {
			belong[j] = i;
		}
		sort(arr.begin()+L[i], arr.begin()+R[i]+1);
	}
}

void modify(int x, int y)
{
	arr.erase(
		lower_bound(arr.begin()+L[belong[x]], arr.begin()+R[belong[x]], a[x])
	);
	arr.insert(
		upper_bound(arr.begin()+L[belong[x]], arr.begin()+R[belong[x]], y), y
	);
	a[x] = y;
}

int get_lower_cnt(int l, int r, int num)
{
	int cnt=0;
	if (belong[l] == belong[r]) {
		for (int i = l; i <= r; ++i) {
			cnt += (a[i]<num);
		}
		return cnt;
	}
	while ( (L[belong[l]]<l) && (l<=R[belong[l]]) ) { cnt+=(a[l]<num), ++l; }
	while ( (L[belong[r]]<=r) && (r<R[belong[r]]) ) { cnt+=(a[r]<num), --r; }
	for (int i = belong[l]; i <= belong[r]; ++i) {
		cnt += lower_bound(arr.begin()+L[i], arr.begin()+R[i]+1, num)-(arr.begin()+L[i]);
	}
	return cnt;
}

int query(int x, int y, int k)
{
	int l=0, r=1e9+5, mid=(l+r)>>1, cnt;
	while (l != r-1) {
		mid=(l+r)>>1, cnt=get_lower_cnt(x, y, mid);
		if (cnt > k-1) {
			r = mid;
		} else {
			l = mid;
		}
	}
	return l;
}

int main()
{
	cin.tie(nullptr) -> sync_with_stdio(false);

	// I.N.
	cin >> n >> q;
	for (int i = 1; i <= n; ++i) { cin>>a[i]; arr[i]=a[i]; }
	init();
	
	// O.P.
	while (q--) {
		char op;
		int x, y, k;
		cin >> op >> x >> y;
		if (op == 'C') {
			modify(x, y);
		} else {
			cin >> k;
			cout << query(x, y, k) << endl;
		}
	}
	
	// E.D.
	return 0;
}
```
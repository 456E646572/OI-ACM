---
tags:
  - 碎片
  - OI/分块
---
## [P4168 [Violet] 蒲公英](https://www.luogu.com.cn/problem/P4168)

强制在线的区间众数问题。

首先会有一个显然的暴力 $O(mn)$ 做法，枚举 $[L,R]$，开个桶记录一下就行了。

由于本题强制在线，$m$ 这个维度是不可能优化掉的，只能从 $n$ 下手。显然，不加任何预处理的情况下，直接扫一遍的 $O(n)$ 解法是获取区间众数的最优做法了。想要优化，就要通过预处理一些量，在多次询问间压缩掉多余的扫描。

提到预处理众数，可能的第一反应就是对每种蒲公英预处理前缀和，**快速求出某段区间内该种蒲公英的数量，进而优化枚举的时间。**

这种思路有两个问题。一是，预处理每种蒲公英的前缀和是 $O(n^2)$ 的运算量，会爆时间和空间。二是，单次询问需要拿到区间内所有出现过的数字，这依然不好维护。

这里参考蓝书上的一种做法，用分块解决这两个问题。

首先，想要求出某段区间 $[L,R]$ 内数字 $x$ 出现的次数，不一定要用前缀和，我们可以牺牲一点查询的时间来换取较为快捷的预处理。具体而言，我们可以对每种蒲公英开一个 `vector`，记作 $cnt[a_i]$，**记录下每种蒲公英的出现位置。每次询问出现的次数时，做两次二分即可**，看有多少下标落在 $[L,R]$ 这个区间内，就是答案。预处理所有蒲公英的时间是 $O(n)$，单次查询 $O(\log n)$，在这里很合适。

然后，【不知道这个区间内出现了哪些数字】的问题其实可以换一个角度看，只需要把对答案计算没用的数字撇去就可以了。假设我们已经知道了区间 $[L,R]$ 的众数，在询问区间 $[L-1,R]$ 的时候会有【两种可能】，要么答案就是 $[L,R]$ 的众数，要么答案是 $a_{L-1}$，换句话说，除了区间 $[L,R]$ 的答案和 $a_{L-1}$，剩下所有数字都是没用的，根本不用看。

引用分块的概念，这里限制时间复杂度的，是散块的大小。设块的大小为 $sz$，一共有 $k$ 个块，通过分块，我们可以将散块的大小限制在 $2sz$ 以内，散块单次查询复杂度 $O(sz\log n)$。

对整块而言，我们需要预处理出第 $l$ 到第 $r$ 个整块的答案，记作 $ans_{[l,r]}$。从块左端点开始向右暴力扫描，开个桶记录出现次数，预处理时间复杂度 $O(kn)$，查询时间复杂度 $O(1)$。

最后求答案的时候，只需要看【整块的众数】和【散块中出现的次数】就可以了。总的来说，预处理时间复杂度 $\displaystyle O(kn)=O(\frac{n^2}{sz})$，查询时间复杂度 $O(m\times sz\log n)$，总时间复杂度 $\displaystyle O(\frac{n^2}{sz}+m\times sz\log n)$，假设 $n,m$ 同构，当左右两部分相等时，即 $\displaystyle sz=\sqrt{\frac{n}{\log n}}$ 时，有时间复杂度最小值 $O(n\sqrt{n\log n})$。

整理一下代码的思路。

1. 分块，块的大小 $sz=n\sqrt{n\log n}$；
2. 枚举块作为左端点，开个桶向右暴力扫描，预处理 $ans_{[l,r]}$，表示第 $l$ 到 $r$ 个块的答案；
3. 预处理 $cnt[a_i]$，表示第 $a[i]$ 种蒲公英出现的下标，开个 `vector` 往里丢就行了；
4. 对于每次询问，对于散块中出现过的数字，可以通过在 $cnt[a[i]]$ 内二分快速求出出现次数，与整块的答案合并，就是询问的答案。

[AC 代码提交记录](https://www.luogu.com.cn/problem/P4168)

（这份代码里面 $sz$ 表示了块的数量，可能跟上文所说不太一样，比较抽象……）

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN=4e4+5, MAXK=805;
int n, m, a[MAXN], b[MAXN], a_to_tp[MAXN], tot;
int k, sz, L[MAXK], R[MAXK], belong[MAXN];
int ans[MAXK][MAXK][2], ht[MAXN];
vector <int> cnt[MAXN];

inline int read()
{
    int ret=0;
    int f=1;
    char c=getchar();
    while(c<'0' || c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0' && c<='9'){
        ret=ret*10+c-'0';
        c=getchar();
    }
    return ret*f;
}

inline int get_frequency(int num, int l_aid, int r_aid)
{
	// 查看在[l_aid,r_aid]之间num出现了多少次
	int rid=upper_bound(
		cnt[num].begin(),cnt[num].end(),r_aid)-cnt[num].begin();
	int lid=lower_bound(
		cnt[num].begin(),cnt[num].end(),l_aid)-cnt[num].begin();
	return rid-lid;
}

inline void update(int num, int fqc, int &tp, int &tpcnt)
{
	if ( (fqc>tpcnt) || (fqc==tpcnt && num<tp)) {
		tp=num, tpcnt=fqc;
	}
}

inline void init()
{
	// 离散化
	sort(b+1, b+n+1), tot=unique(b+1, b+n+1)-(b+1);
	for (int i = 1; i <= n; ++i) {
		a_to_tp[i] = lower_bound(b+1, b+tot+1, a[i])-(b);
	}
	
	// 分块信息
	sz=sqrt(n*log(n)), sz=(sz==0? 1: sz), k=n/sz;
	for (int i = 1; i <= sz; ++i) {
		L[i]=(i-1)*k+1, R[i]=i*k;
	}
	if (R[sz] < n) {
		++k, L[sz]=R[sz-1]+1, R[sz]=n;
	}
	for (int i = 1; i <= sz; ++i) {
		for (int j = L[i]; j <= R[i]; ++j) {
			belong[j]=i;
			cnt[a_to_tp[j]].push_back(j);  // 预处理cnt[a[i]]，表示a[i]种蒲公英出现的下标
		}
	}
	
	// 预处理ans[l][r]
	// 枚举左端点，然后枚举右端点进行操作
	// 对于a[i]，它属于第belong[a[i]]个块，用二分看它在[i,belong[a[i]]]这些块中出现了多少次
	// 记下a[i]的答案，不清空、只更新
	// 直到这一个块扫完，将答案填入ans[l][r]
	for (int i = 1; i <= sz; ++i) {
		int tp=0, tpcnt=0;  // tp : type
		memset(ht, 0, sizeof(ht));
		for (int j = i; j <= sz; ++j) {
			for (int z = L[j]; z <= R[j]; ++z) {  // 对一个块内进行扫描，每次处理a[z]的答案
				update(a_to_tp[z], ++ht[a_to_tp[z]], tp, tpcnt);
			}
			ans[i][j][0]=tp, ans[i][j][1]=tpcnt;
		}
	}
}

inline int query(int l, int r)
{
	int i=l, j=r, tp=0, tpcnt=0;
	
	// 求散块的答案
	while ( (L[belong[i]]<i) && (i<=R[belong[i]]) ) {
		// 收缩左边界，对于a[i]，看它在左侧散块中出现了多少次
		update(a_to_tp[i], get_frequency(a_to_tp[i], l, r), tp, tpcnt), ++i;
	}
	while ( (L[belong[j]]<=j) && (j<R[belong[j]]) ) {
		// 同上收缩右边界
		update(a_to_tp[j], get_frequency(a_to_tp[j], l, r), tp, tpcnt); --j;
	}
	
	// 将整块的答案合并
	if (tpcnt == ans[ belong[i] ][ belong[j] ][1]) {  // 频次相同，取编号较小
		tp = min(tp, ans[ belong[i] ][ belong[j] ][0]);
	} else if (tpcnt < ans[ belong[i] ][ belong[j] ][1]) {  // 整块答案频次大，否则就不更新
		tp = ans[ belong[i] ][ belong[j] ][0];
	}
	
	// 返回答案
	return tp;
}

int main()
{
	cin.tie(nullptr) -> sync_with_stdio(false);
	n=read(), m=read();
	for (int i = 1; i <= n; ++i) {
		a[i]=read(), b[i]=a[i];
	}
	
	// 预处理：分块、块的答案
	init();
	
	// Q.E.
	int x=0, l, r;
	while (m--) {
		// 输入询问 and 解密
		// cin >> l >> r;
		// scanf("%d%d", &l, &r);
		l=read(), r=read();
		l=(l+x-1)%n+1, r=(r+x-1)%n+1;
		if (l > r) { swap(l,r); }
		
		// 处理询问
		x = b[query(l,r)];
		
		printf("%d\n", x);
	}
	
	// E.D.
	return 0;
}
```
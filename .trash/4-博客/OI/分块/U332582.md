---
tags:
  - 碎片
  - OI/分块
---
## [树上距离](https://www.luogu.com.cn/problem/U332582)

校内模拟赛的一道题，不知道有没有原题，自己搓的数据，可能有点水。

常规的暴力做法是 $O(1)$ 做单点修改，$O(n)$ 做单次 bfs 查询。或者 $O(n)$ 把全局的距离全部更新，$O(1)$ 做单点查询。接下来自然的一个想法，就是牺牲一点修改或者查询的时间，使两者达到平衡。

本题的正解是对操作序列分块，将一些修改操作堆积在一起，一次性做完。

具体而言，设现在每个节点到其最近红色节点的距离为 $dis_i$ ，块长为 $k$，队列当前为空。

每当遇到一个修改操作，直接将其加入队列。期间如果遇到对节点 $u$ 的查询，利用 【st 表+欧拉序】在 $O(1)$ 时间内求出队列中每个节点到 $u$ 的距离，再与 $dis_u$ 取较小值即可，时间复杂度 $O(qk)$。

当队列中堆积的修改操作大于 $k$ 后，用 bfs 进行一次全局修改。这种操作共进行 $\displaystyle\frac{q}{k}$ 次，时间复杂度 $\displaystyle O(\frac{qn}{k})$。

总时间复杂度 $\displaystyle O(qk+\frac{qn}{k})$，假设 $q,n$ 同构，当 $k=\sqrt n$ 时有时间复杂度最小值 $O(n\sqrt n)$。

注：倍增求两点距离的话，目前的数据是 80 分。

[AC 代码提交记录](https://www.luogu.com.cn/record/122804692)

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN=1e5+5, MAXI=17;
int n, q, k, dis[MAXN], depth[MAXN];
int sz, euler[MAXN<<1], fst[MAXN], st[MAXN<<1][MAXI+5];
vector <int> G[MAXN], T;
bool vis[MAXN];

void dfs(int u, int fa)
{
	depth[u] = depth[fa] + 1;
	euler[++sz] = u;
	fst[u] = sz;
	for (int v: G[u]) {
		if (v != fa) { dfs(v, u); euler[++sz]=u; }
	}
}

void build_st()
{
	for (int i = 1; i <= sz; ++i) { st[i][0] = euler[i]; }
	for (int i = 1; i <= log2(sz); ++i) {
		for (int j = 1; j+(1<<i)-1 <= sz; ++j) {
			int lv=st[j][i-1], rv=st[j+(1<<(i-1))][i-1];
			st[j][i] = (depth[lv]<depth[rv]? lv: rv);
		}
	}
}

int get_lca(int l, int r)
{
	int len = log2(r-l+1);
	int lv=st[l][len], rv=st[r-(1<<len)+1][len];
	return (depth[lv]<depth[rv]? lv: rv);
}

void modify()
{
	queue <int> q;
	for (int nd: T) { dis[nd]=0; q.push(nd); }
	T.clear();
	memset(vis, 0, sizeof(vis));
	while (!q.empty()) {
		int u=q.front(); q.pop();
		if (vis[u]) { continue; }
		vis[u] = true;
		for (int v: G[u]) {
			dis[v] = min(dis[v], dis[u]+1);
			q.push(v);
		}
	}
}

int main()
{
//	freopen("tree2.in", "r", stdin);
//	freopen("tree.out", "w", stdout);
	cin >> n >> q;
	k = sqrt(q);
	for (int i = 1; i < n; ++i) {
		int u, v; cin >> u >> v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	dfs(1, 0);
	build_st();
	T.push_back(1);
	memset(dis, 0x3f3f3f3f, sizeof(dis));
	while (q--) {
		int op, u; cin >> op >> u;
		if (op == 1) {  // O(nq/k)
			T.push_back(u);
			if (int(T.size()) >= k) { modify(); }
		} else {  // O(kn)
			int ans = dis[u];
			for (int nd: T) {
				int x = fst[u];
				int y = fst[nd];
				if (x > y) { swap(x,y); }
				int lca = get_lca(x, y);
				ans = min(ans, depth[u]+depth[nd]-2*depth[lca]);
			}
			cout << ans << endl;
		}
	}
	return 0;
}
```
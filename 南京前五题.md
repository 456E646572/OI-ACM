## [B. Birthday Gift](https://codeforces.com/gym/105484/problem/B)

假设原串中的 $\texttt{2}$ 已经分配完毕，将字符串所有偶数位置取反，则原串中的两个相邻的相同的字符，对应了新串中两个相邻的不同的字符。不断删去两个相邻的不同的字符直到不能删除，得到的字符串要么全部为 $\texttt{0}$，要么全部为 $\texttt{1}$。这是因为，如果字符串中同时存在 $\texttt{0}$ 和 $\texttt{1}$，则必然有一个 $\texttt{0}$ 和一个 $\texttt{1}$ 相邻，于是可以继续进行操作。
因此，统计原串偶数位取反后 $\texttt{0}$ 和 $\texttt{1}$ 的个数，用 $\texttt{2}$ 尽可能弥补两者的数量差，最后 $\texttt{2}$ 与 $\texttt{2}$ 之间相互抵消即可。
关于这个 trick 详见[一些 trick（14）| 奇数位反转](https://www.luogu.com.cn/article/7n7vxer5)

#### [AC代码](https://codeforces.com/gym/105484/submission/291205535)

```cpp
#include <bits/stdc++.h>

using namespace std;

void solve()
{
    string s; cin >> s;
    int cnt[3]={0};
    for (int i = 0; i < (int)s.length(); ++i) {
        if (s[i] == '2') { ++cnt[2]; continue; }
        ++cnt[(s[i]-'0')^(i&1)];
    }
    int d = abs(cnt[0]-cnt[1]);
    if (cnt[2]<=d) { cout << d-cnt[2] << endl; }
    else           { cout << (cnt[2]-d)%2 << endl; }
}

int main()
{
    int t; cin >> t;
    while (t--) { solve(); }
}
```

## [E. Left Shifting 3](https://codeforces.com/gym/105484/problem/E)

最多左移 $7$ 次就可以把开头的 $\texttt{nanjing}$ 移到结尾，消除截断点。
因此直接模拟 $\min(n,7)$ 次，枚举计算答案即可。

#### [AC 代码](https://codeforces.com/gym/105484/submission/291133564)

```cpp
#include <bits/stdc++.h>

using namespace std;

void solve()
{
    int n, k, ans=0;
    string s;
    cin >> n >> k >> s;
    for (int i = 0; i <= min({k,7}); ++i) {
        int cnt = 0;
        for (int j = 0; j+6 < n; ++j) {
            if (s.substr(j, 7)=="nanjing") { ++cnt; }
        }
        ans = max(ans, cnt);
        s = s.substr(1) + s[0];
    }
    cout << ans << endl;
}

int main()
{
    int t; cin >> t;
    while (t--) { solve(); }
}
```

## [G. Binary Tree](https://codeforces.com/gym/105484/problem/G)

看见 $\lfloor\log_2 n\rfloor$ 这个询问次数的限制，联想到树的重心的性质，据此“二分”。
每次询问，先 $O(n)$ 找到树的重心 $u$。
如果 $u$ 的度数为 $0$，即剩余节点数等于 $1$，则直接输出。
如果 $u$ 的度数为 $1$，即剩余节点数等于 $2$，询问 $u$ 和另一个节点即可。为方便写代码，此时可以令下文中的 $son_1=u,son_2=v$，统一操作。
如果 $u$ 的度数等于 $2$ 或 $3$，则可以将这棵树分为若干部分：①以 $son_1$ 为根的最大连通块，②以 $son_2$ 为根的次大连通块，③剩余部分（当 $u$ 的度数等于 $2$ 时该部分只有 $u$ 一个节点，当 $u$ 的度数等于 $3$ 时该部分为 $u$ 和最小的连通块）。
询问 $son_1,son_2$。不难发现：如果 $t=0$，那么只有①会被保留；如果 $t=1$，那么只有③会被保留；如果 $t=2$，那么只有②会被保留。
根据树的重心的性质，①②两部分的大小都不超过 $\lfloor\dfrac{n}{2}\rfloor$。而最小的连通块大小加 $1$ 一定不超过 $\lfloor\dfrac{n}{2}\rfloor$，度数为 $2$ 时显然，度数为 $3$ 时 $n\geq4\Rightarrow\lfloor\dfrac{n}{2}\rfloor\geq2$，若反之则三个连通块的大小 $sz > 3\times(\lfloor\dfrac{n}{2}\rfloor-1)+1=3\times\lfloor\dfrac{n}{2}\rfloor-2\geq2\times\lfloor\dfrac{n}{2}\rfloor\geq n$，矛盾。
因此每次询问结束后，问题的规模会变为 $\lfloor\dfrac{n}{2}\rfloor$，可以在 $\lfloor\log_2 n\rfloor$ 的次数限制内解决问题。

#### [AC 代码](https://codeforces.com/gym/105484/submission/299423229)

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N=1e5+5;
int n, rm, dis1[N], dis2[N], cnt[N];
bool isBan[N];
vector <int> G[N];

void read()
{
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        G[i].clear();
        isBan[i] = false;
    }
    for (int i = 1; i <= n; ++i) {
        int x, y;
        cin >> x >> y;
        if (x != 0) { G[i].push_back(x); G[x].push_back(i); }
        if (y != 0) { G[i].push_back(y); G[y].push_back(i); }
    }
}
int query(int u, int v)
{
    cout << "? " << u << " " << v << endl;
    int t; cin >> t;
    return t;
}
void answer(int s)
{
    cout << "! " << s << endl;
}
void findBaryCenter(int u, int fa, int &core, int &son1, int &son2)
{
    cnt[u] = 1;
    vector <pair<int,int>> vec;
    for (int v: G[u]) {
        if (v != fa && !isBan[v]) {
            findBaryCenter(v, u, core, son1, son2);
            cnt[u] += cnt[v];
            vec.push_back( { cnt[v], v } );
        }
    }
    if (fa != 0) { vec.push_back( { rm-cnt[u], fa } ); }
    sort(vec.begin(), vec.end());
    if (vec.back().first * 2 <= rm) {
        core = u;
        son1 = vec.back().second;
        if (vec.size() >= 2) { son2 = vec[vec.size()-2].second; }
        else { son2 = u; }
    }
}
void updateDis(int u, int fa, int d, int dis[])
{
    dis[u] = d;
    for (int v: G[u]) {
        if (v != fa && !isBan[v]) { updateDis(v, u, d+1, dis); }    
    }
}
void banNode(int u, int fa, int t)
{
    if (
        t == 0 && dis1[u] >= dis2[u] ||
        t == 1 && dis1[u] != dis2[u] ||
        t == 2 && dis1[u] <= dis2[u]
    ) { --rm; isBan[u] = true; }
    for (int v: G[u]) {
        if (v != fa && !isBan[v]) { banNode(v, u, t); }
    }
}
void solve()
{
    read();
    rm = n;
    int root = 1;
    while (rm > 1) {
        int core, son1, son2;
        findBaryCenter(root, 0, core, son1, son2);
        updateDis(son1, 0, 0, dis1);
        updateDis(son2, 0, 0, dis2);
        banNode(root, 0, query(son1, son2));
        if (!isBan[son1]) { root = son1; }
        else if (!isBan[son2]) { root = son2; }
        else { root = core; }
    }
    answer(root);
}
int main()
{
    int t; cin >> t;
    while (t--) { solve(); }
}
```

## [J. Social Media](https://codeforces.com/gym/105484/problem/J)

建图。如果 $a_i$ 和 $b_i$ 之间有评论则连边，边权为评论数量。
将评论分为三种：①双方都是好友，②只有一方是好友，③都不是好友。
对于第①种评论，直接计入答案即可，记该部分和为 $ans_1$。
对于第②种评论，对每个非初始好友 $i$ 统计 $v_i$，表示如果选择 $i$ 作为好友，会新增 $v_i$ 条第二种评论。
对于第③种评论，可以通过枚举边的方式找到，能新增的评论数量是边权，记为 $w(a,b)$。
最后答案为
$$
ans_1+\max\{ \max_{i\ne j}\{v_i+v_j\}, \max_{a,b不是初始好友}\{v_a+v_b+w(a,b)\}\}
$$

#### [AC 代码](https://codeforces.com/gym/105484/submission/291200235)

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N=2e5+5;
int n, m, k, v[N];
unordered_set <int> fr;
map<pair<int,int>,int> G;

void solve()
{
    cin >> n >> m >> k;
    fr.clear();
    for (int i = 1; i <= n; ++i) {
        int frr; cin >> frr;
        fr.insert(frr);
    }
    int ans1=0;
    memset(v, 0, sizeof(v));
    G.clear();
    for (int i = 1; i <= m; ++i) {
        int a, b;
        cin >> a >> b;
        if (a > b) { swap(a,b); }
        if (fr.count(a) && fr.count(b)) {
            ans1++;
        } else if (fr.count(a)) {
            v[b]++;
        } else if (fr.count(b)) {
            v[a]++;
        } else if (a==b) {
            v[a]++;
        } else {
            G[{a,b}]++;
        }
    }
    int ans2=0;
    for (auto it=G.begin(); it!=G.end(); ++it) {
        int a=it->first.first;
        int b=it->first.second;
        int w=it->second;
        if (a!=b && !fr.count(a) && !fr.count(b)) {
            ans2=max(ans2, v[a]+v[b]+w);
        }
    }
    sort(v+1, v+k+1, greater<int>());
    ans2 = max(ans2, v[1]+v[2]);
    cout << ans1+ans2 << endl;
}

int main()
{
    int t; cin >> t;
    while (t--) { solve(); }
}
```

## [K. Strips](https://codeforces.com/gym/105484/problem/K)

新增 $0$ 和 $w+1$ 两个黑点，把相邻两个黑点中间一段取出，原问题转化为：用最少的条数覆盖红点，且不超出边界。
如果不考虑边界限制，只需要从左到右枚举红点，如果该点尚未覆盖，就新增一条左端点在该点的纸条。
加上边界限制后，上述算法只有最右侧的红点可能越界，此时我们可以从右往左将每一条纸条左移，记从左往右每条纸条的端点为 $L[i],R[i]$，则需要左移的距离为 $d=L[i+1]-R[i]$。左移操作完成后，如果左侧越界则无解。由于只有每个区间的最右侧红点会触发左移操作，且每个纸条至多左移一次，故左移操作的次数为 $O(ans)=O(n+m)$。
总时间复杂度为 $O((n+m)\log(n+m))$，主要为排序的复杂度。

#### [AC 代码](https://codeforces.com/gym/105484/submission/291203753)

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N=1e5+5;
int n, m, w, k, a[N], b[N];
vector <int> ans;

bool work(int L, int R, int &rd)
{
    while (rd<=n && a[rd]<R) {
        if (ans.empty() || ans.back()+k-1 < a[rd]) { ans.push_back(a[rd]);}
        if (ans.back()+k-1 >= R) {
            int d;
            for (auto it=ans.rbegin(); it!=ans.rend(); ++it) {
                if (it == ans.rbegin()) { d = ans.back()+k-1-R+1; }
                else { d = *it+k-1-*(it-1)+1; }
                if (d <= 0) { break; }
                if (*it < L) { break; }
                if (*it - d <= L) { return false; }
                *it -= d;
            }
        }
        ++rd;
    }
    return true;
}

void solve()
{
    cin >> n >> m >> k >> w;
    for (int i = 1; i <= n; ++i) { cin >> a[i]; } sort(a+1, a+n+1);
    b[0]=0; b[m+1]=w+1;
    for (int i = 1; i <= m; ++i) { cin >> b[i]; } sort(b, b+m+2);
    int rd=1;
    ans.clear();
    for (int i = 1; i <= m+1; ++i) {
        if (rd > n) { break; }
        if (!work(b[i-1], b[i], rd)) { cout << -1 << endl; return; }
    }
    cout << ans.size() << endl;
    for (int p: ans) { cout << p << " "; }
    cout << endl;
}

int main()
{
    int t; cin >> t;
    while (t--) { solve(); }
}
```

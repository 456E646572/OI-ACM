---
tags:
  - 模板
  - 计算几何
---
向量旋转 $\begin{bmatrix}\cos\theta & -\sin\theta\\ \sin\theta & \cos\theta\end{bmatrix}\begin{bmatrix}a_x\\a_y\end{bmatrix}=\begin{bmatrix}\cos\theta a_x & -\sin\theta a_y\\ \sin\theta a_x & \cos\theta a_y\end{bmatrix}$
```cpp
typedef long long ll;
typedef double db;  // 视情况改为 long double
const db eps=1e-8;  // 极端数据下，放大 eps 可能有奇效
int sgn(int x) { return x==0? 0: ( x>0? 1: -1 ); }
int sgn(db x) { return fabs(x)<eps? 0: ( x>0? 1: -1 ); }

// 为方便不写 template，题目中坐标为浮点数时可用 db 代替 int/ll
struct Point {
	int x, y;
    Point(db x=0, db y=0): x(x), y(y) {}
    void in() { cin >> x >> y; }
	string info() {
        return "("+to_string(x)+","+to_string(y)+")";
    }
    bool operator < (const Point &p) const {
    	return x<p.x || (x==p.x && y<p.y);
    }
    Point operator + (const Point &p) const {
    	return {x+p.x, y+p.y};
    }
    Point operator - (const Point &p) const {
        return {x-p.x, y-p.y};
    }
	Point operator * (const db &k) const {
	    return {k*x, k*y};
	}
	ll operator * (const Point &p) const {
	    return x*p.x+y*p.y;
	}
	ll operator ^ (const Point &p) const { // 叉乘，可能会爆 ll，用的时候记得打括号
	    return x*p.y - y*p.x;
	}
    ll len2() { return (*this)*(*this); }
    db len() { return sqrtl(this->len2()); }  // 不可改 ll
};
typedef Point Vector;

//判断 c 是否在 ab 的逆时针方向
int toLeft(Point a, Point b, Point c) {
    return ((b-a)^(c-a))>0;
}

//二维向量夹角，rad值
double Angle(Vector A, Vector B) {
    return acos(Dot(A,B)/Length(A)/Length(B));
}

//三角形面积的二倍
double Area2(Point A, Point B, Point C) {
    return Cross(B-A,C-A);
}

//向量逆时针旋转rad角度
Vector Rotate(Vector A, double rad) {
    return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));
}

//向量A逆时针转90°后的单位向量
Vector Normal(Vector A) {
    double L=Length(A);
    return Vector(-A.y/L,A.x/L);
}
```
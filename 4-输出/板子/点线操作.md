---
tags:
  - 模板
  - 计算几何
---
点 $P$ 在直线 $AB$ 上，则 $\overrightarrow{AB}\times\overrightarrow{AP}=\vec{0}$，若要求在线段/射线上，再判断 $x,y$ 是否分别位于 $AB$ 之间即可。
判断两线段是否相交：先做两次跨立实验判断是否规范相交，再特判至少三点共线的情况
点 $P$ 到直线 $(A,\vec{v})$ 距离：$\dfrac{\|\vec{v}\times\overrightarrow{AP}\|}{\|\vec{v}\|}$，投影点 $B$ 满足 $\vec{OB}=\vec{OA}+\dfrac{\vec{v}\cdot\overrightarrow{AB}}{\vec{v}^2}\vec{v}$
两直线 $(P_1,\vec{v_1}),(P_2,\vec{v_2})$ 的交点 $Q$ 满足：$\overrightarrow{OQ}=\overrightarrow{OP_1}+\dfrac{\|\vec{v_2}\times\overrightarrow{P_2P_1}\|}{\|\vec{v_1}\times\vec{v_2}\|}\vec{v_1}$

```cpp
// 线段，射线，直线三合一
struct Line {
    Point a, b;
    Vector v;
    int lx, ly, rx, ry;
    Line(Point a, Point v): a(a), v(v) {  // 注意此处用起点和方向向量构建，不是起点和终点
        b = a+v;
        lx = min(a.x, b.x);
        rx = max(a.x, b.x);
        ly = min(a.y, b.y);
        ry = max(a.y, b.y);
    }
	// 判断 c 是否在射线的逆时针方向
	int toLeft(Point p) {
	    return sgn(v^(p-a));
	}
    // 判断点 P 是否在线段上，包含端点
    bool onSegment(Point p) {
        bool f1 = toLeft(p)==0;
        // 将下面四个等号全部去掉就不包含端点了
        bool f2 = (lx <= p.x && p.x <= rx);
        bool f3 = (ly <= p.y && p.y <= ry);
        return f1 && f2 && f3;
    }
};

// 判断两条线段是否相交
bool hasIntersection(Line L1, Line L2)
{
    if (L1.onSegment(L2.a) || L1.onSegment(L2.b) || L2.onSegment(L1.a) || L2.onSegment(L1.b)) {
        return true;
    }
    bool crossStanding = [&](Line L, Point a, Point b) {  // 跨立实验
        return L.toLeft(a)*L.toLeft(b) == -1;
    }
    // 线段端点分布在直线两侧，“线段与线段/线段与直线/直线与直线”是否相交对应修改即可
    return crossStanding(L1, L2.a, L2.b) && crossStanding(L2, L1.a, L2.a);
}

// 求两直线交点
// 求之前应该先判断有没有交点，避免精度误差，同时还要特判平行的情况
Point getIntersection(Line L1, Line L2)
{
    Point P1=L1.a, P2=L2.a;
    Vector v1=L1.v, v2=L2.v;
    return P1 + v1 * ( (v2^(P1-P2)) / (v1^v2) );
}

//点P到直线AB的距离公式
double DistanceToLine(Point P, Point A, Point B) {
    Vector v1=B-A, v2=P-A;
    return fabs(Cross(v1,v2)/Length(v1));
}

//点P到线段AB的距离公式
double DistanceToSegment(Point P, Point A, Point B) {
    if(A==B) return Length(P-A);
    Vector v1=B-A, v2=P-A, v3=P-B;
    if(dcmp(Dot(v1,v2))<0) return Length(v2);
    if(dcmp(Dot(v1,v3))>0) return Length(v3);
    return DistanceToLine(P,A,B);
}

//点P在直线AB上的投影点
Point GetLineProjection(Point P, Point A, Point B) {
    Vector v=B-A;
    return A+v*(Dot(v,P-A)/Dot(v,v));
}
```

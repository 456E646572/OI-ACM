---
tags:
  - 输出
  - 线段树
  - 模板
---
需要自定义 `info` 和 `lazyTag`，重写两个带默认值的构造函数和三个运算符，并修改 `build()` 中对 `info` 的新建。
```cpp
struct lazyTag {
	lazyTag() { }  // 记得写默认值
};
struct info {
    int l, r;
    int len() { return r-l+1; }
    info(int l=INT_MAX, int r=0): l(l), r(r) { }  // 记得写默认值
    bool operator <= (const pair<int,int> &p) const {
        return p.first <= l && r <= p.second;
    }
};
info operator + (info f1, info f2) {
}
info operator + (info f, lazyTag tag) {
}
lazyTag operator + (lazyTag t1, lazyTag t2) {
}
struct segmentTree {
    #define lson (pos << 1) 
    #define rson (pos << 1 | 1)
    struct node {
        info val;
        lazyTag tag;
    };
    int n;
    vector <int> p;
    vector <node> t;
    segmentTree(int n): n(n) {
        p.resize(n+1);
        for (int i = 1; i <= n; ++i) { cin >> p[i]; }  // 这两行输入原始数组，如无需要记得删
        t.resize( (n+5) << 2 );
        build(1, 1, n);
    }
    void push_up(int pos) {
        t[pos].val = t[lson].val + t[rson].val;
    }
    void setTag(int pos, const lazyTag &tag) {
        t[pos].val = t[pos].val + tag;
        t[pos].tag = t[pos].tag + tag;
    }
    void spread_down(int pos) {
    	setTag(lson, t[pos].tag);
    	setTag(rson, t[pos].tag);
    	t[pos].tag = lazyTag();
    }
    void build(int pos, int l, int r) {
        if (l == r) {
            t[pos].val = info(p[l], l, r);  // 根据 info() 构造函数修改
        } else {
            int mid = (l + r) >> 1;
            build(lson, l, mid);
            build(rson, mid+1, r);
            push_up(pos);
        }
    }
    void modify(int pos, int l, int r, const lazyTag &tag) {  // 区间修改
        if (t[pos].val <= make_pair(l, r)) {
            setTag(pos, tag);
        } else {
            int mid = (t[pos].val.l + t[pos].val.r) >> 1;
            spread_down(pos);
            if (l <= mid) { modify(lson, l, r, tag); }
            if (mid < r)  { modify(rson, l, r, tag); }
            push_up(pos);
        }
    }
    info query(int pos, int l, int r) {  // 区间查询
        if (t[pos].val <= make_pair(l, r)) {
            return t[pos].val;
        } else {
            int mid = (t[pos].val.l + t[pos].val.r) >> 1;
            spread_down(pos);
            info res = info();
            if (l <= mid) { res = res + query(lson, l, r); }
            if (mid < r)  { res = res + query(rson, l, r); }
            return res;
        }
    }
};
```
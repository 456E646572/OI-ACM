---
tags:
  - 输出
  - 线段树
  - 模板
---
需要自定义 `info` 和 `tag`，重写两个带默认值的构造函数和三个运算符。
```cpp
struct info {
    int l, r;
    int len() { return r-l+1; } 
    info(int l=INT_MAX, int r=0): l(l), r(r) {}  // 记得写默认值
};
info operator + (const info &v1, const info &v2) {
}
struct tag {  // 懒标记
    tag() {}  // 记得写默认值
};
info operator + (info v1, const tag &t) {  // 懒标记
}
tag operator + (const tag &t1, const tag &t2) {  // 懒标记
}
struct segmentTree {
    #define lson (pos << 1) 
    #define rson (pos << 1 | 1)
    struct node {
        info v;
        tag t;  // 懒标记
    };
    vector <node> t;
    segmentTree(int n) {
        t.resize( (n+5) << 4 );
        build(1, 1, n);
    }
    void push_up(int pos) {
        t[pos].v = t[lson].v + t[rson].v;
    }
    void setTag(int pos, const tag &tg) {  // 懒标记
        t[pos].v = t[pos].v + tg;
        t[pos].t = t[pos].t + tg;
    }
    void spread_down(int pos) {  // 懒标记
    	setTag(lson, t[pos].t);
    	setTag(rson, t[pos].t);
    	t[pos].t = tag();
    }
    void build(int pos, int l, int r) {
        t[pos].v = info(l, r);
        if (l == r) { return; }
        int mid = (l + r) >> 1;
        build(lson, l, mid);
        build(rson, mid+1, r);
        push_up(pos);
    }
    void modify(int pos, int l, int r, const tag &tag) {  // 区间修改，不需要懒标记时改参数
    	if (t[pos].v.r < l || r < t[pos].v.l) { return; }
        if (l <= t[pos].v.l && t[pos].v.r <= r) {
            setTag(pos, tag); push_up(pos); return;  // 不要漏 return
        }
        spread_down(pos);  // 懒标记
        modify(lson, l, r, tag);  // 懒标记
        modify(rson, l, r, tag);  // 懒标记
        push_up(pos);
    }
    info query(int pos, int l, int r) {  // 区间查询
    	if (t[pos].v.l < l || r < t[pos].v.r) { return info(); }
        if (l <= t[pos].v.l && t[pos].v.r <= r) {
            return t[pos].v;
        }
        int mid = (t[pos].v.l + t[pos].v.r) >> 1;
        spread_down(pos);  // 懒标记
        info res = info();
        res = res + query(lson, l, r);
        res = res + query(rson, l, r);
        return res;
    }
};
```
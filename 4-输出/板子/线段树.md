---
tags:
  - 输出
  - 线段树
  - 模板
---
```cpp
struct lazyTag {
	lazyTag() { }
    lazyTag operator + (const lazyTag &tag) const { }
};
struct info {
    int l, r;
    info(int l=INT_MAX, int r=0): l(l), r(r) { }
    bool operator <= (const pair<int,int> &p) const {
        return p.first <= l && r <= p.second;
    }
    info operator + (const info &f) const { }
    info operator + (const lazyTag &tag) const { }
};
struct segmentTree {
    #define lson (pos << 1) 
    #define rson (pos << 1 | 1)
    struct node {
        info val;
        lazyTag tag;
    };
    int n;
    vector <int> p;
    vector <node> t;
    segmentTree(int n): n(n) {
        p.resize(n+1);
        for (int i = 1; i <= n; ++i) { cin >> p[i]; }
        t.resize(n<<2);
        build(1, 1, n);
    }
    void push_up(int pos) {
        t[pos].val = t[lson].val + t[rson].val;
    }
    void setTag(int pos, const lazyTag &tag) {
        t[pos].val = t[pos].val + tag;
        t[pos].tag = t[pos].tag + tag;
    }
    void spread_down(int pos) {
        t[lson].val = t[lson].val + t[pos].tag;
        t[lson].tag = t[lson].tag + t[pos].tag;
        t[rson].val = t[rson].val + t[pos].tag;
        t[rson].tag = t[rson].tag + t[pos].tag;
        t[pos].tag = lazyTag();
    }
    void build(int pos, int l, int r) {
        if (l == r) {
            t[pos].val = info(p[l], l, r);
        } else {
            int mid = (l + r) >> 1;
            build(lson, l, mid);
            build(rson, mid+1, r);
            push_up(pos);
        }
    }
    void modify(int pos, int l, int r, const lazyTag &tag) {
        if (t[pos].val <= make_pair(l, r)) {
            setTag(pos, tag);
        } else {
            int mid = (t[pos].val.l + t[pos].val.r) >> 1;
            spread_down(pos);
            if (l <= mid) { modify(lson, l, r, tag); }
            if (mid < r)  { modify(rson, l, r, tag); }
            push_up(pos);
        }
    }
    info query(int pos, int l, int r) {
        if (t[pos].val <= make_pair(l, r)) {
            return t[pos].val;
        } else {
            int mid = (t[pos].val.l + t[pos].val.r) >> 1;
            spread_down(pos);
            info res = info();
            if (l <= mid) { res = res + query(lson, l, r); }
            if (mid < r)  { res = res + query(rson, l, r); }
            return res;
        }
    }
};
```
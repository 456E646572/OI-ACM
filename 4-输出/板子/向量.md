---
tags:
  - 模板
  - 计算几何
---
向量旋转 $\begin{bmatrix}\cos\theta & -\sin\theta\\ \sin\theta & \cos\theta\end{bmatrix}\begin{bmatrix}a_x\\a_y\end{bmatrix}=\begin{bmatrix}\cos\theta a_x & -\sin\theta a_y\\ \sin\theta a_x & \cos\theta a_y\end{bmatrix}$
```cpp
// 为方便不写 template，题目中坐标为浮点数时可用 db 代替 int/ll
struct Point {
	int x, y;
    Point(int x=0, int y=0): x(x), y(y) {}
    void in() { cin >> x >> y; }
    void print() { cout << x << " " << y << "\n"; }
	string info(string name) {
		return format("{}({},{})", name, x, y);  // c++20
	}
	Point operator + (const Point &p) const {
        return Point(x+p.x, y+p.y);
    }
    Point operator - (const Point &p) const {
        return Point (x-p.x, y-p.y);
    }
	Point operator * (const db &k) const {
		return Point(k*x, k*y);
	}
	Point operator / (const db &k) const {
		return Point(x/k, y/k);
	}
	ll operator * (const Point &p) const {
	    return x*p.x+y*p.y;
	}
	ll operator ^ (const Point &p) const { // 叉乘，用的时候记得打括号
	    return x*p.y - y*p.x;
	}
	/* 
	bool operator < (const Point &p) const {
		return x<p.x || (x==p.x && y<p.y);
	}
	*/
	int quad() {  // 下半平面 < 原点和 x 轴正半轴 < 上半平面 < x 轴负半轴
	    if (y < 0)       { return 1; }
	    else if (y > 0)  { return 3; }
	    else if (x >= 0) { return 2; }
	    else             { return 4; }
	}
	bool operator < (const Point &p) const {  // 极角排序
	    Point a=*this, b=p;
	    int qa = a.quad(), qb = b.quad();
	    if (qa == qb) {
	        ll cross = a^b;
	        if (cross == 0) { return abs(a.x) < abs(b.x); }
	        return cross > 0;
	    }
	    return qa < qb;
	}
	ll len2() {
	    return (*this)*(*this);
	}
	db len() {  // 不可改 ll
	    return sqrtl(len2());  // hypotl(x, y)
	}
	Point rotate(db ang) {
	    return Point(x*cos(ang)-y*sin(ang), x*sin(ang)+y*cos(ang));
	}
	Point trunc(db l) {
	    return (*this) * (l/len());
	}
};
typedef Point Vector;

// 判断 c 是否在 ab 的逆时针方向
int toLeft(Point a, Point b, Point c)
{
    return ((b-a)^(c-a))>0;
}

// 三角形面积，如需避免浮点数，可以返回二倍面积
db S(Point A, Point B, Point C)
{
    return 0.5*fabs((A-B)^(A-C));
};

// 二维向量夹角
db getAngle(Vector a, Vector b)
{
    return fabs(atan2(fabs(a^b), a*b));
}

// 余弦定理求第三边
db getThirdSide(Vector a, Vector b)
{
    return sqrtl(a.len2() + b.len2() - a*b*2);
}
```
